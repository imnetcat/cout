#pragma once
#include <map>#include <vector>namespace Cout{	namespace Network	{		namespace Protocol		{			namespace SMTP			{				static const std::string XMAILER = "Mailer";				class MAIL				{				public:					MAIL();					virtual ~MAIL();					const std::string createHeader();					void AddRecipient(const std::string& email, const std::string& name = "");					void AddBCCRecipient(const std::string& email, const std::string& name = "");					void AddCCRecipient(const std::string& email, const std::string& name = "");					void AddAttachment(const std::string& path);					void AddMsgLine(const std::string& text) noexcept;					void ClearMessage() noexcept;					void DelRecipients(void) noexcept;					void DelBCCRecipients(void) noexcept;					void DelCCRecipients(void) noexcept;					void DelAttachments(void) noexcept;					void DelMsgLines(void) noexcept;					void DelMsgLine(unsigned int line);					void ModMsgLine(unsigned int line, const char* text);					const char* GetMsgLineText(unsigned int line) const noexcept;					size_t GetMsgLines(void) const noexcept;					size_t GetBodySize() const noexcept;					const std::vector<std::string>& GetBody() const noexcept;					size_t GetAttachmentsSize() const noexcept;					const std::vector<std::string>& GetAttachments() const noexcept;					void SetCharSet(const std::string&) noexcept;					void SetSubject(const std::string&) noexcept;					void SetSenderName(const std::string&) noexcept;					void SetSenderMail(const std::string&) noexcept;					void SetReplyTo(const std::string&) noexcept;					void SetReadReceipt(bool requestReceipt = true) noexcept;					void SetXMailer(const std::string&) noexcept;					const std::string& GetReplyTo() const noexcept;					const std::string& GetMailFrom() const noexcept;					const std::string& GetSenderName() const noexcept;					const std::string& GetSubject() const noexcept;					const std::string& GetXMailer() const noexcept;					const std::string& GetSenderMail() const noexcept;					const std::string& GetCharSet() const noexcept;					using Recipients = std::map<std::string, std::string>;					size_t GetBCCRecipientCount() const noexcept;					size_t GetCCRecipientCount() const noexcept;					size_t GetRecipientCount() const noexcept;					const Recipients& GetBCCRecipient() const noexcept;					const Recipients& GetCCRecipient() const noexcept;					const Recipients& GetRecipient() const noexcept;					enum PRIORITY					{						HIGH = 2,						NORMAL = 3,						LOW = 4					};					static const std::string BOUNDARY_TEXT;					PRIORITY GetXPriority() const noexcept;					void SetXPriority(PRIORITY priority = PRIORITY::NORMAL) noexcept;				private:					std::string senderMail;					std::string senderName;					std::string subject;					std::string charSet = "US-ASCII";					std::string mailer;					std::string replyTo;					bool readReceipt = false;					Recipients recipients;					Recipients ccrecipients;					Recipients bccrecipients;					std::vector<std::string> attachments;					std::vector<std::string> body;					PRIORITY priority = NORMAL;					bool html = false;				};			}		}	}}
#include <filesystem>namespace Cout{	namespace Core	{		namespace Filesystem		{			namespace fs = std::filesystem;			using Path = fs::path;		}	}}
namespace Cout{	using SignedByte = char;	using UnsignedByte = unsigned char;}
namespace Cout{	namespace Core	{		namespace Filesystem		{			class IDescryptor			{			public:				virtual ~IDescryptor() {};				virtual void remove() const = 0;				virtual bool exist() const = 0;			};			class Descryptor : public IDescryptor			{			public:				Descryptor(const Path& p) : _path(p) {};				bool exist() const override				{					fs::file_status s = fs::status(_path);					bool result = fs::status_known(s) ? fs::exists(s) : fs::exists(_path);					return result;				}				void remove() const override				{					fs::remove_all(_path);				}			protected:				Path _path;			};			class IExDescryptor : public Descryptor			{			public:				IExDescryptor() : Descryptor("") {}				virtual ~IExDescryptor() {};				virtual void create() const = 0;				virtual size_t size() const = 0;				virtual Path path() const = 0;				virtual void path(const Path&) = 0;				bool operator==(const IExDescryptor& obj)				{					return this->path().filename() == obj.path().filename();				}			};		}	}}
namespace Cout{	namespace Core	{		namespace Filesystem		{			class FileDescryptor : public IExDescryptor			{			public:				FileDescryptor() {};				FileDescryptor(const Path& p);				void remove() const override;				void create() const override;				size_t size() const override;				Path path() const override;				void path(const Path& new_path) override;			};		}	}}
#include <string>#include <stdexcept>// check MVSC++, GCC debug preprocessor derective#if defined(_DEBUG) || defined(DEBUG_MODE)#define INDEBUG#endif#ifdef INDEBUG#define LOG_LEVEL_MIN 1#define LOG_LEVEL_DEB 2#define LOG_LEVEL_FULL 3#define LOG_LEVEL LOG_LEVEL_FULL#endif
namespace Cout{	namespace Exceptions	{		class base		{		public:			base(const std::exception& ex);			base(const std::string msg_where, const std::string msg_what);			virtual ~base() {};			// get hex id of exception			//virtual const std::string id() const noexcept = 0;			// indicates what exactly went wrong			virtual const std::string what() const noexcept = 0;			const std::string& when() const noexcept			{				return _when;			}			const std::string& where() const noexcept			{				return _where;			}			//			const std::string log() const noexcept;			//			const std::string log(const std::string&, const std::string&) const noexcept;		private:			// indicates under what condition an exception was raised			// for example "when: something = 1, and = some_other"			const std::string _when;			// indicates where in the program an error occurred			const std::string _where;		};	}}#define LEFT_SEP "("#define RGHT_SEP ")"#define _EXCEPTION__WRAP_FORMAT_(filep, lsep, lineno, rsep) filep lsep lineno rsep#define _EXCEPTION__WRAP_DLEVEL_(filep, lineno) _EXCEPTION__WRAP_FORMAT_(filep, LEFT_SEP, #lineno, RGHT_SEP)#define _EXCEPTION__WRAP_(filep, lineno) _EXCEPTION__WRAP_DLEVEL_(filep, lineno)#ifdef INDEBUG#define WHERE _EXCEPTION__WRAP_(__FILE__, __LINE__)#else#define WHERE _EXCEPTION__WRAP_("", __LINE__)#endif
Cout::Exceptions::base::base(const std::exception& ex) : _when(ex.what()) {}Cout::Exceptions::base::base(const std::string en, const std::string ere)	: _when(en), _where(ere) { };const std::string Cout::Exceptions::base::log() const noexcept{	std::string log;//#ifdef INDEBUG	log += "\twhat  : " + what() + "\n";	log += "\twhen  : " + _when + "\n";	log += "\twhere : " + _where + "\n";//#else	//log = id();	//log += _where;//#endif	return log;}const std::string Cout::Exceptions::base::log(const std::string& when_preppend, const std::string& where_preppend) const noexcept{	std::string log;//#ifdef INDEBUG	log += "\twhat  : " + what() + "\n";	log += "\twhen  : " + when_preppend + "\n\t\t" + _when + "\n";	log += "\twhere : " + where_preppend + "\n\t\t" + _where + "\n";//#else	//log = id();	//log += _where;//#endif	return log;}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class invalid_argument : public base			{			public:				invalid_argument(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Invalid argument or variable not specified";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class file_not_exist : public base			{			public:				file_not_exist(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "File not exist";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class file_already_exist : public base			{			public:				file_already_exist(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "File already exist";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class access_denied : public base			{			public:				access_denied(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "access denied or file is busy";				}			};		}	}}
#include <fstream>Cout::Core::Filesystem::Path Cout::Core::Filesystem::FileDescryptor::path() const{	return _path;}void Cout::Core::Filesystem::FileDescryptor::path(const Path& new_path){	if (new_path.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "path is empty");	fs::file_status s = fs::status(new_path);	bool exist = fs::status_known(s) ? fs::exists(s) : fs::exists(new_path);	if (exist && fs::is_directory(new_path))		throw Cout::Exceptions::Core::invalid_argument(WHERE, "path contains dir not a file");	_path = new_path;}Cout::Core::Filesystem::FileDescryptor::FileDescryptor(const Path& p){	path(p);}size_t Cout::Core::Filesystem::FileDescryptor::size() const{	if (!exist())		throw Cout::Exceptions::Core::file_not_exist(WHERE, "checking file size");	return fs::file_size(_path);}void Cout::Core::Filesystem::FileDescryptor::remove() const{	if (!exist())		throw Cout::Exceptions::Core::file_not_exist(WHERE, "deleting unexisted file");	Descryptor::remove();}void Cout::Core::Filesystem::FileDescryptor::create() const{	if (exist())		throw Cout::Exceptions::Core::file_already_exist(WHERE, "creating new file");	auto temp = _path;	temp.remove_filename();	if (!fs::exists(temp))	{		fs::create_directories(temp);	}	std::ofstream file(_path, std::ios::binary);	file.close();}
namespace Cout{	namespace Core	{		namespace Filesystem		{			struct Collection;			class DirDescryptor : public IExDescryptor			{			public:				DirDescryptor(const Path& p);				void remove() const override;				void create() const override;				size_t size() const override;				Path path() const override;				void path(const Path& new_path) override;				Collection listing() const;			};			struct Collection			{				std::vector<DirDescryptor> dirs;				std::vector<FileDescryptor> files;				bool contains(const IExDescryptor& d)				{					bool result = std::count(files.begin(), files.end(), d);					if (!result)						result = std::count(dirs.begin(), dirs.end(), d);					return result;				}				void append(const Collection& other)				{					for (auto& dir : other.dirs)						dirs.push_back(dir);					for (auto& file : other.files)						files.push_back(file);				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class dir_not_exist : public base			{			public:				dir_not_exist(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Directory not exist";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class dir_already_exist : public base			{			public:				dir_already_exist(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Directory already exist";				}			};		}	}}
Cout::Core::Filesystem::Path Cout::Core::Filesystem::DirDescryptor::path() const{	return _path;}void Cout::Core::Filesystem::DirDescryptor::path(const Path& new_path){	if (new_path.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "path is empty");	fs::file_status s = fs::status(new_path);	bool exist = fs::status_known(s) ? fs::exists(s) : fs::exists(new_path);	if (exist && !fs::is_directory(new_path))		throw Cout::Exceptions::Core::invalid_argument(WHERE, "path contains file not a dir");	_path = new_path;}Cout::Core::Filesystem::DirDescryptor::DirDescryptor(const Path& p){	path(p);}size_t Cout::Core::Filesystem::DirDescryptor::size() const{	if (!exist())		throw Cout::Exceptions::Core::dir_not_exist(WHERE, "checking dir size");	size_t result = 0;	for (const auto & entry : std::filesystem::directory_iterator(_path))	{		if (entry.is_directory())			result += DirDescryptor(entry.path()).size();		else			result += FileDescryptor(entry.path()).size();	}	return result;}void Cout::Core::Filesystem::DirDescryptor::remove() const{	if (!exist())		throw Cout::Exceptions::Core::dir_not_exist(WHERE, "deleting unexisted dir");	Descryptor::remove();}void Cout::Core::Filesystem::DirDescryptor::create() const{	if (exist())		throw Cout::Exceptions::Core::dir_already_exist(WHERE, "creating new dir");	fs::create_directories(_path);}Cout::Core::Filesystem::Collection Cout::Core::Filesystem::DirDescryptor::listing() const{	if (!exist())		throw Cout::Exceptions::Core::dir_not_exist(WHERE, "listing unexisted dir");	Collection listing;	for (const auto & entry : std::filesystem::directory_iterator(_path))	{		if (entry.is_directory())			listing.dirs.push_back(entry.path());		else			listing.files.push_back(entry.path());	}	return listing;}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Copyable			{			public:				virtual ~Copyable() {}				virtual void copy(const DirDescryptor& dist) const = 0;			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class non_readable : public base			{			public:				non_readable(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Could not readable";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class non_writable : public base			{			public:				non_writable(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Could not writable";				}			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class CopyableDir : public Copyable, virtual public DirDescryptor			{			public:				CopyableDir(const Path& p) : DirDescryptor(p) {};				void copy(const DirDescryptor& dest) const override				{					if (!exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "source folder not found when copying");					if (!dest.exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "destination not found when copying");					if (dest.listing().contains((*this)))						throw Cout::Exceptions::Core::file_already_exist(WHERE, "copying destination already contains source folder");					auto dir_name = _path.filename();					fs::copy(_path, dest.path() / dir_name, std::filesystem::copy_options::recursive);				}			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Moveable			{			public:				virtual ~Moveable() {}				virtual void move(const DirDescryptor& dist) = 0;			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class MoveableDir : public Moveable, virtual public DirDescryptor			{			public:				MoveableDir(const Path& p) : DirDescryptor(p) {};				void move(const DirDescryptor& dest) override				{					if (!exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "source folder not found when moving");					if (!dest.exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "destination not found when moving");					if (dest.listing().contains((*this)))						throw Cout::Exceptions::Core::dir_already_exist(WHERE, "moving destination already contains source folder");					auto dir_name = _path.filename();					fs::copy(_path, dest.path() / dir_name, std::filesystem::copy_options::recursive);					remove();					_path = dest.path() / dir_name;				}			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Dir :				public CopyableDir,				public MoveableDir,				virtual public DirDescryptor			{			public:				Dir(const Path&);			};		}	}}
Cout::Core::Filesystem::Dir::Dir(const Path& p) :	CopyableDir(p),	MoveableDir(p),	DirDescryptor(p) {}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class CopyableFile : public Copyable, virtual public FileDescryptor			{			public:				CopyableFile() {}				CopyableFile(const Path& p) : FileDescryptor(p) {}				void copy(const DirDescryptor& dest) const override				{					if (!exist())						throw Cout::Exceptions::Core::file_not_exist(WHERE, "source file not found when copying");					if (!dest.exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "destination not found when copying");					if (dest.listing().contains((*this)))						throw Cout::Exceptions::Core::file_already_exist(WHERE, "copying destination already contains source file");					bool test_o_access = std::ofstream(_path, std::ios::app).good();					if (!test_o_access)						throw Cout::Exceptions::Core::non_readable(WHERE, "copyable file descryptor busy");					bool test_i_access = std::ifstream(_path).good();					if (!test_i_access)						throw Cout::Exceptions::Core::non_writable(WHERE, "copyable files descryptor busy");					fs::copy(_path, dest.path());				}			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class MoveableFile : public Moveable, virtual public FileDescryptor			{			public:				MoveableFile() {}				MoveableFile(const Path& p) : FileDescryptor(p) {}				void move(const DirDescryptor& dest) override				{					if (!exist())						throw Cout::Exceptions::Core::file_not_exist(WHERE, "source file not found when moving");					if (!dest.exist())						throw Cout::Exceptions::Core::dir_not_exist(WHERE, "destination not found when moving");					if (dest.listing().contains((*this)))						throw Cout::Exceptions::Core::file_already_exist(WHERE, "moving destination already contains source file");					bool test_o_access = std::ofstream(_path, std::ios::app).good();					if (!test_o_access)						throw Cout::Exceptions::Core::non_readable(WHERE, "moving file descryptor busy");					bool test_i_access = std::ifstream(_path).good();					if (!test_i_access)						throw Cout::Exceptions::Core::non_writable(WHERE, "moving file descryptor busy");					auto file_name = _path.filename();					fs::copy(_path, dest.path() / file_name);					remove();					_path = dest.path() / file_name;				}			};		}	}}
#include <vector>#include <string>namespace Cout{	struct Binary : public std::vector<SignedByte>	{		Binary() {};		Binary(const SignedByte* init, size_t size)		{			Assign(init, size);		}		Binary(const std::string& init)		{			Assign(init.data(), init.size());		}		void operator = (const std::string& init)		{			Assign(init.data(), init.size());		}		void operator += (const std::string& init)		{			Append(init.data(), init.size());		}		void Assign(const SignedByte* data, size_t size)		{			this->clear();			Append(data, size);		}		void Append(const SignedByte* data, size_t size)		{			for (unsigned int i = 0; i < size; i++)			{				this->push_back(data[i]);			}		}	};	struct UnsignedBinary : public std::vector<UnsignedByte>	{		void Assign(const UnsignedByte* data, size_t size)		{			this->clear();			for (unsigned int i = 0; i < size; i++)			{				this->push_back(data[i]);			}		}	};}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Readable			{			public:				virtual ~Readable() {}				virtual Binary read(size_t bytes2read, size_t start_pos = 0) = 0;			};		}	}}
namespace Cout{	namespace Core	{		namespace Filesystem		{			class OpenCloseable			{			public:				virtual ~OpenCloseable() {}				virtual void open() = 0;				virtual void close() = 0;			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class ReadableFile : public Readable, virtual public OpenCloseable, virtual public FileDescryptor			{			public:				ReadableFile() {}				ReadableFile(const Path& p);				virtual ~ReadableFile();				Binary read(size_t bytes2read, size_t start_pos = 0) override;				void open() override;				void close() override;				void open4read();				void close4read();			private:				std::ifstream rhandle;				bool readable;			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class out_of_range : public base			{			public:				out_of_range(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Out of range";				}			};		}	}}
#include <iterator>Cout::Core::Filesystem::ReadableFile::ReadableFile(const Path& p) :	FileDescryptor(p) {}Cout::Core::Filesystem::ReadableFile::~ReadableFile(){	close();};Cout::Binary Cout::Core::Filesystem::ReadableFile::read(size_t bytes2read, size_t start_pos){	rhandle.seekg(start_pos, std::ios::beg);	size_t s = size();	if (start_pos + bytes2read > s)		throw Cout::Exceptions::Core::non_readable(WHERE, "open empty file for reading");	SignedByte *buffer = new SignedByte[bytes2read];		rhandle.read(buffer, bytes2read);	return { buffer, bytes2read };}void Cout::Core::Filesystem::ReadableFile::open(){	if (!exist())		throw Cout::Exceptions::Core::file_not_exist(WHERE, "open file for reading");	if (!size())		throw Cout::Exceptions::Core::non_readable(WHERE, "open empty file for reading");	rhandle = std::ifstream(_path, std::ios::binary);	readable = rhandle && size();	if (!rhandle)		throw Cout::Exceptions::Core::access_denied(WHERE, "open file for reading");}void Cout::Core::Filesystem::ReadableFile::close(){	rhandle.close();	readable = false;}void Cout::Core::Filesystem::ReadableFile::open4read(){	ReadableFile::open();}void Cout::Core::Filesystem::ReadableFile::close4read(){	ReadableFile::close();}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Writeable			{			public:				virtual ~Writeable() {}				virtual void write(const Binary& data) = 0;				virtual std::ofstream& whandle() = 0;			};		}	}}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class WriteableFile : public Writeable, virtual public OpenCloseable, virtual public FileDescryptor			{			public:				WriteableFile(const Path& p);				virtual ~WriteableFile();				void write(const Binary& data) override;				std::ofstream& whandle() override;				void open() override;				void close() override;				void open4write();				void close4write();			private:				std::ofstream _whandle;				bool writeable;			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class logic_error : public base			{			public:				logic_error(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Logic error";				}			};		}	}}
Cout::Core::Filesystem::WriteableFile::WriteableFile(const Path& p) :	FileDescryptor(p) {}Cout::Core::Filesystem::WriteableFile::~WriteableFile(){	close();};std::ofstream& Cout::Core::Filesystem::WriteableFile::whandle(){	return _whandle;}void Cout::Core::Filesystem::WriteableFile::write(const Cout::Binary& data){	if (!exist())		throw Cout::Exceptions::Core::file_not_exist(WHERE, "write file");	if (!_whandle)		throw Cout::Exceptions::Core::logic_error(WHERE, "writing in file first you need to open the file for writing");	for(size_t i = 0; i < data.size(); i++)		_whandle << data[i];}void Cout::Core::Filesystem::WriteableFile::open(){	if (!exist())		throw Cout::Exceptions::Core::file_not_exist(WHERE, "open file for reading");	_whandle = std::ofstream(_path, std::ios::binary | std::ios::app);	writeable = _whandle && size();	if (!_whandle)		throw Cout::Exceptions::Core::access_denied(WHERE, "open file for reading");}void Cout::Core::Filesystem::WriteableFile::close(){	_whandle.close();	writeable = false;}void Cout::Core::Filesystem::WriteableFile::open4write(){	WriteableFile::open();}void Cout::Core::Filesystem::WriteableFile::close4write(){	WriteableFile::close();}
#include <vector>#include <fstream>#include <istream>namespace Cout{	namespace Core	{		namespace Filesystem		{			class File :				public CopyableFile,				public MoveableFile,				public ReadableFile,				public WriteableFile			{			public:				File(const Path&);				~File();				void open() override;				void close() override;			};		}	}}
Cout::Core::Filesystem::File::File(const Path& p) :	CopyableFile(p),	MoveableFile(p),	ReadableFile(p),	WriteableFile(p),	FileDescryptor(p) {}Cout::Core::Filesystem::File::~File(){	close();}void Cout::Core::Filesystem::File::open(){	ReadableFile::open();	WriteableFile::open();}void Cout::Core::Filesystem::File::close(){	ReadableFile::close();	WriteableFile::close();}
#include <functional>#include <vector>namespace Cout{	namespace Core	{		namespace Filesystem		{			class ContextMenu			{			public:				using ReadCallback = std::function<void(const Binary&)>;				static void remove(const IDescryptor& source);				static void create(const IExDescryptor& source);				static bool exist(const IDescryptor& p);				static size_t size(const IExDescryptor& p);				static Collection listing(const DirDescryptor& dir);				static void read(ReadableFile& file, size_t block_size, ReadCallback callback);				static Binary read(ReadableFile& file);				static void write(WriteableFile& file, const Binary& data);				static void move(MoveableFile& source, const DirDescryptor& dest);				static void move(MoveableDir& source, const DirDescryptor& dest);				static void copy(const CopyableFile& source, const DirDescryptor& dest);				static void copy(const CopyableDir& source, const DirDescryptor& dest);			};		}	}}
void Cout::Core::Filesystem::ContextMenu::remove(const IDescryptor& source){	source.remove();}void Cout::Core::Filesystem::ContextMenu::create(const IExDescryptor& source){	source.create();}bool Cout::Core::Filesystem::ContextMenu::exist(const IDescryptor& d){	return d.exist();}size_t Cout::Core::Filesystem::ContextMenu::size(const IExDescryptor& d){	return d.size();}Cout::Core::Filesystem::Collection Cout::Core::Filesystem::ContextMenu::listing(const DirDescryptor& dir){	return dir.listing();}void Cout::Core::Filesystem::ContextMenu::write(WriteableFile& file, const Cout::Binary& data){	file.open4write();	file.write(data);	file.close4write();}void Cout::Core::Filesystem::ContextMenu::read(ReadableFile& file, size_t block_size, ReadCallback callback){	file.open4read();	size_t size = file.size();	for (size_t pos = 0; pos < size; pos += block_size)	{		if (pos + block_size > size)			block_size = size - pos;		callback(file.read(block_size, pos));	}	file.close4read();}Cout::Binary Cout::Core::Filesystem::ContextMenu::read(ReadableFile& file){	file.open4read();	Binary data = file.read(file.size(), 0);	file.close4read();	return data;}void Cout::Core::Filesystem::ContextMenu::move(MoveableFile& source, const DirDescryptor& dest){	source.move(dest);}void Cout::Core::Filesystem::ContextMenu::move(MoveableDir& source, const DirDescryptor& dest){	source.move(dest);}void Cout::Core::Filesystem::ContextMenu::copy(const CopyableDir& source, const DirDescryptor& dest){	source.copy(dest);}void Cout::Core::Filesystem::ContextMenu::copy(const CopyableFile& source, const DirDescryptor& dest){	source.copy(dest);}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class undefined : public base			{			public:				undefined(const std::exception& ex) : base(ex) { };				undefined(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Undefined error";				}			};		}	}}
namespace Cout{	namespace Exceptions	{		namespace Core		{			class lack_of_memory : public base			{			public:				lack_of_memory(const std::string whre, const std::string when)					: base(whre, when) {};				const std::string what() const noexcept override				{					return "Lack of memory";				}			};		}	}}
using namespace Cout::Exceptions;namespace Cout{	namespace Network	{		namespace Protocol		{			namespace Exceptions			{				namespace wsa				{					class startup : virtual public base					{					public:						startup(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA startup failed";						}					};					class version : virtual public base					{					public:						version(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Invalid WSA version";						}					};					class send : virtual public base					{					public:						send(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA send error";						}					};					class recv : virtual public base					{					public:						recv(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA recv error";						}					};					class connect : virtual public base					{					public:						connect(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA connect";						}					};					class gethostby_name_addr : virtual public base					{					public:						gethostby_name_addr(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA gethost by name/addr failed";						}					};					class invalid_socket : virtual public base					{					public:						invalid_socket(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA invalid socket";						}					};					class hostname : virtual public base					{					public:						hostname(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA invalid hostname";						}					};					class ioctlsocket : virtual public base					{					public:						ioctlsocket(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA ioctlsocket filed";						}					};					class bad_ipv4_addr : virtual public base					{					public:						bad_ipv4_addr(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "bad ipv4 addr";						}					};					class select_timeout : virtual public base					{					public:						select_timeout(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA select timeout";						}					};					class select : virtual public base					{					public:						select(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "WSA select failed";						}					};					class server_not_responding : virtual public base					{					public:						server_not_responding(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Server not responding";						}					};					class connect_failed : virtual public base					{					public:						connect_failed(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Failed connect to server";						}					};					class already_connect : virtual public base					{					public:						already_connect(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Connection already exist";						}					};					class connection_closed : virtual public base					{					public:						connection_closed(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Connection closed";						}					};					class sendbuf_is_empty : virtual public base					{					public:						sendbuf_is_empty(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Send buffer is empty";						}					};					class recvbuf_is_empty : virtual public base					{					public:						recvbuf_is_empty(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Recv buffer is empty";						}					};				}			}		}	}}
using namespace Cout::Exceptions;namespace Cout{	namespace Network	{		namespace Protocol		{			namespace Exceptions			{				namespace smtp				{					class command_not_recognized : virtual public base					{					public:						command_not_recognized(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Command not recognized";						}					};					class undef_mail_from : virtual public base					{					public:						undef_mail_from(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Undefined mail sender";						}					};					class undef_recipients : virtual public base					{					public:						undef_recipients(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Undefined at least one reciepent";						}					};					class undef_login : virtual public base					{					public:						undef_login(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Undefined user login";						}					};					class undef_password : virtual public base					{					public:						undef_password(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Undefined user password";						}					};					class auth_failed : virtual public base					{					public:						auth_failed(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP authentication failed";						}					};					class command_failed : virtual public base					{					public:						command_failed(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP Server returned an error in response to the command";						}					};					class msg_body_error : virtual public base					{					public:						msg_body_error(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP Error in message body";						}					};					class msg_too_big : virtual public base					{					public:						msg_too_big(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP letter cannot be more than 25 megabytes";						}					};					class bad_credentials : virtual public base					{					public:						bad_credentials(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP Invalid password/login or access denied from insecure applications";						}					};					class undef_response : virtual public base					{					public:						undef_response(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP Undefined xyz SMTP response";						}					};					class time_error : virtual public base					{					public:						time_error(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP time() error";						}					};					class tls_not_supported : virtual public base					{					public:						tls_not_supported(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP The STARTTLS command is not supported by the server";						}					};					class auth_not_supported : virtual public base					{					public:						auth_not_supported(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP AUTH LOGIN is not supported by the server";						}					};					class undef_command : virtual public base					{					public:						undef_command(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "SMTP undefined command specified";						}					};				}			}		}	}}
#include <sstream>Cout::Network::Protocol::SMTP::MAIL::MAIL() : mailer(XMAILER){ }Cout::Network::Protocol::SMTP::MAIL::~MAIL() { }const std::string& Cout::Network::Protocol::SMTP::MAIL::GetSenderMail() const noexcept{	return senderMail;}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetCharSet() const noexcept{	return charSet;}void Cout::Network::Protocol::SMTP::MAIL::AddAttachment(const std::string& Path){	if (Path.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "input empty path");	if (!Core::Filesystem::ContextMenu::exist(Core::Filesystem::Descryptor(Path)))		throw Cout::Exceptions::Core::file_not_exist(WHERE, "SMTP attachment file not found");	attachments.insert(attachments.end(), Path);}void Cout::Network::Protocol::SMTP::MAIL::AddRecipient(const std::string& email, const std::string& name){	if (email.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "recipient email is empty");	recipients[email] = name;}void Cout::Network::Protocol::SMTP::MAIL::AddCCRecipient(const std::string& email, const std::string& name){	if (email.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "recipient email is empty");	ccrecipients[email] = name;}void Cout::Network::Protocol::SMTP::MAIL::AddBCCRecipient(const std::string& email, const std::string& name){	if (email.empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "recipient email is empty");	bccrecipients[email] = name;}void Cout::Network::Protocol::SMTP::MAIL::AddMsgLine(const std::string& Text) noexcept{	body.insert(body.end(), Text);}void Cout::Network::Protocol::SMTP::MAIL::DelMsgLine(unsigned int Line){	if (Line >= body.size())		throw Cout::Exceptions::Core::out_of_range(WHERE, "deleting line of message body");	body.erase(body.begin() + Line);}void Cout::Network::Protocol::SMTP::MAIL::DelRecipients() noexcept{	recipients.clear();}void Cout::Network::Protocol::SMTP::MAIL::DelBCCRecipients() noexcept{	bccrecipients.clear();}void Cout::Network::Protocol::SMTP::MAIL::DelCCRecipients() noexcept{	ccrecipients.clear();}void Cout::Network::Protocol::SMTP::MAIL::DelMsgLines() noexcept{	body.clear();}void Cout::Network::Protocol::SMTP::MAIL::DelAttachments() noexcept{	attachments.clear();}void Cout::Network::Protocol::SMTP::MAIL::ModMsgLine(unsigned int Line, const char* Text){	if (Line >= body.size())		throw Cout::Exceptions::Core::out_of_range(WHERE, "modify line of message body");	body.at(Line) = std::string(Text);}void Cout::Network::Protocol::SMTP::MAIL::ClearMessage() noexcept{	DelRecipients();	DelBCCRecipients();	DelCCRecipients();	DelAttachments();	DelMsgLines();}size_t Cout::Network::Protocol::SMTP::MAIL::GetBodySize() const noexcept{	return body.size();}const std::vector<std::string>& Cout::Network::Protocol::SMTP::MAIL::GetBody() const noexcept{	return body;}size_t Cout::Network::Protocol::SMTP::MAIL::GetAttachmentsSize() const noexcept{	return attachments.size();}const std::vector<std::string>& Cout::Network::Protocol::SMTP::MAIL::GetAttachments() const noexcept{	return attachments;}const Cout::Network::Protocol::SMTP::MAIL::Recipients& Cout::Network::Protocol::SMTP::MAIL::GetBCCRecipient() const noexcept{	return bccrecipients;}const Cout::Network::Protocol::SMTP::MAIL::Recipients& Cout::Network::Protocol::SMTP::MAIL::GetCCRecipient() const noexcept{	return ccrecipients;}const Cout::Network::Protocol::SMTP::MAIL::Recipients& Cout::Network::Protocol::SMTP::MAIL::GetRecipient() const noexcept{	return recipients;}size_t Cout::Network::Protocol::SMTP::MAIL::GetRecipientCount() const noexcept{	return recipients.size();}size_t Cout::Network::Protocol::SMTP::MAIL::GetBCCRecipientCount() const noexcept{	return bccrecipients.size();}size_t Cout::Network::Protocol::SMTP::MAIL::GetCCRecipientCount() const noexcept{	return ccrecipients.size();}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetReplyTo() const noexcept{	return replyTo;}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetMailFrom() const noexcept{	return senderMail;}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetSenderName() const noexcept{	return senderName;}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetSubject() const noexcept{	return subject;}const std::string& Cout::Network::Protocol::SMTP::MAIL::GetXMailer() const noexcept{	return mailer;}Cout::Network::Protocol::SMTP::MAIL::PRIORITY Cout::Network::Protocol::SMTP::MAIL::GetXPriority() const noexcept{	return priority;}const char* Cout::Network::Protocol::SMTP::MAIL::GetMsgLineText(unsigned int Line) const noexcept{	return body.at(Line).c_str();}size_t Cout::Network::Protocol::SMTP::MAIL::GetMsgLines() const noexcept{	return body.size();}void Cout::Network::Protocol::SMTP::MAIL::SetCharSet(const std::string& sCharSet) noexcept{	charSet = sCharSet;}void Cout::Network::Protocol::SMTP::MAIL::SetXPriority(Protocol::SMTP::MAIL::PRIORITY p) noexcept{	priority = p;}void Cout::Network::Protocol::SMTP::MAIL::SetReplyTo(const std::string& ReplyTo) noexcept{	replyTo = ReplyTo;}void Cout::Network::Protocol::SMTP::MAIL::SetReadReceipt(bool requestReceipt) noexcept{	readReceipt = requestReceipt;}void Cout::Network::Protocol::SMTP::MAIL::SetSenderMail(const std::string& SMail) noexcept{	senderMail = SMail;}void Cout::Network::Protocol::SMTP::MAIL::SetSenderName(const std::string& Name) noexcept{	senderName = Name;}void Cout::Network::Protocol::SMTP::MAIL::SetSubject(const std::string& Subject) noexcept{	subject = Subject;}void Cout::Network::Protocol::SMTP::MAIL::SetXMailer(const std::string& XMailer) noexcept{	mailer = XMailer;}const std::string Cout::Network::Protocol::SMTP::MAIL::createHeader(){	char month[][4] = { "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec" };	bool first_elem = true;	std::stringstream to;	std::stringstream cc;	std::stringstream bcc;	std::stringstream sheader;	time_t rawtime;	struct tm* timeinfo = new tm[sizeof(tm)];	// date/time check	if (time(&rawtime) > 0)		localtime_s(timeinfo, &rawtime);	else		throw Cout::Network::Protocol::Exceptions::smtp::time_error(WHERE, "creating SMTP header");	// check for at least one recipient	if (recipients.size())	{		for (const auto& [mail, name] : recipients)		{			if (first_elem)				to << ',';			first_elem = false;			to << name;			to << '<';			to << mail;			to << '>';		}	}	else		throw Cout::Network::Protocol::Exceptions::smtp::undef_recipients(WHERE, "creating SMTP header");	if (ccrecipients.size())	{		for (const auto&[mail, name] : ccrecipients)		{			if (first_elem)				to << ',';			first_elem = false;			to << name;			to << '<';			to << mail;			to << '>';		}	}	if (bccrecipients.size())	{		for (const auto&[mail, name] : bccrecipients)		{			if (first_elem)				to << ',';			first_elem = false;			to << name;			to << '<';			to << mail;			to << '>';		}	}	// Date: <SP> <dd> <SP> <mon> <SP> <yy> <SP> <hh> ":" <mm> ":" <ss> <SP> <zone> <CRLF>	sheader << "Date: " <<		timeinfo->tm_mday << " " <<		month[timeinfo->tm_mon] << " " <<		timeinfo->tm_year + 1900 << " " <<		timeinfo->tm_hour << ":" <<		timeinfo->tm_min << ":" <<		timeinfo->tm_sec << "\r\n";	delete[] timeinfo;	// From: <SP> <sender>  <SP> "<" <sender-email> ">" <CRLF>	if (!senderMail.size())		throw Cout::Network::Protocol::Exceptions::smtp::undef_mail_from(WHERE, "creating SMTP header");	sheader << "From: ";	if (senderName.size()) sheader << senderName;	sheader << " <";	sheader << senderMail;	sheader << ">\r\n";	// X-Mailer: <SP> <xmailer-app> <CRLF>	if (mailer.size())	{		sheader << "X-Mailer: ";		sheader << mailer;		sheader << "\r\n";	}	// Reply-To: <SP> <reverse-path> <CRLF>	if (replyTo.size())	{		sheader << "Reply-To: ";		sheader << replyTo;		sheader << "\r\n";	}	// Disposition-Notification-To: <SP> <reverse-path or sender-email> <CRLF>	if (readReceipt)	{		sheader << "Disposition-Notification-To: ";		if (replyTo.size()) sheader << replyTo;		else sheader << senderName;		sheader << "\r\n";	}	// X-Priority: <SP> <number> <CRLF>	switch (priority)	{	case PRIORITY::HIGH:		sheader << "X-Priority: 2 (High)\r\n";		break;	case PRIORITY::NORMAL:		sheader << "X-Priority: 3 (Normal)\r\n";		break;	case PRIORITY::LOW:		sheader << "X-Priority: 4 (Low)\r\n";		break;	default:		sheader << "X-Priority: 3 (Normal)\r\n";	}	// To: <SP> <remote-user-mail> <CRLF>	sheader << "To: ";	sheader << to.str();	sheader << "\r\n";	// Cc: <SP> <remote-user-mail> <CRLF>	if (ccrecipients.size())	{		sheader << "Cc: ";		sheader << cc.str();		sheader << "\r\n";	}	if (bccrecipients.size())	{		sheader << "Bcc: ";		sheader << bcc.str();		sheader << "\r\n";	}	// Subject: <SP> <subject-text> <CRLF>	if (!subject.size())		sheader << "Subject:  ";	else	{		sheader << "Subject: ";		sheader << subject;	}	sheader << "\r\n";	// MIME-Version: <SP> 1.0 <CRLF>	sheader << "MIME-Version: 1.0\r\n";	if (!attachments.size())	{ // no attachments		if (html) sheader << "Content-Type: text/html; charset=\"";		else sheader << "Content-type: text/plain; charset=\"";		sheader << charSet;		sheader << "\"\r\n";		sheader << "Content-Transfer-Encoding: 7bit\r\n";		sheader << "\r\n";	}	else	{ // there is one or more attachments		sheader << "Content-Type: multipart/mixed; boundary=\"";		sheader << BOUNDARY_TEXT;		sheader << "\"\r\n";		sheader << "\r\n";		// first goes text message		sheader << "--";		sheader << BOUNDARY_TEXT;		sheader << "\r\n";		if (html) sheader << "Content-type: text/html; charset=";		else sheader << "Content-type: text/plain; charset=";		sheader << charSet;		sheader << "\r\n";		sheader << "Content-Transfer-Encoding: 7bit\r\n";		sheader << "\r\n";	}	sheader << '\0';	return sheader.str();}const std::string Cout::Network::Protocol::SMTP::MAIL::BOUNDARY_TEXT = "__MESSAGE__ID__54yg6f6h6y456345";
#include <openssl/ssl.h>#include <openssl/err.h>#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")#pragma comment (lib, "crypt32")#ifdef INDEBUG#pragma comment (lib, "libcrypto64MTd.lib")#pragma comment (lib, "libssl64MTd.lib")#else#pragma comment (lib, "libcrypto64MT.lib")#pragma comment (lib, "libssl64MT.lib")#endifnamespace Cout{	namespace Encryption	{		class OpenSSL		{		public:			OpenSSL();			~OpenSSL();		protected:			SSL_CTX*      ctx;			SSL*          ssl;		};	}}
using namespace Cout::Exceptions;namespace Cout{	namespace Encryption	{		namespace Exceptions		{			class openssl_problem : virtual public base			{			public:				openssl_problem(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "OpenSSL undefined error";				}			};			class openssl_zero_return : virtual public base			{			public:				openssl_zero_return(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "The TLS/SSL peer has closed the connection for writing by sending the close_notify alert";				}			};			class openssl_syscall : virtual public base			{			public:				openssl_syscall(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "Some non-recoverable, fatal I/O error occurred";				}			};			class openssl_want_async : virtual public base			{			public:				openssl_want_async(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "The operation did not complete because an asynchronous engine is still processing data";				}			};			class openssl_want_lookup : virtual public base			{			public:				openssl_want_lookup(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "The operation did not complete because an application callback set by \SSL_CTX_set_client_cert_cb() has asked to be called again";				}			};			class openssl_want_accept : virtual public base			{			public:				openssl_want_accept(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "The underlying BIO was not connected yet to the peer \and the call would block in accept()";				}			};			class openssl_want_connect : virtual public base			{			public:				openssl_want_connect(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "The underlying BIO was not connected yet to the peer \and the call would block in connect()";				}			};			class aes_256_gcm_problem : virtual public base			{			public:				aes_256_gcm_problem(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "AES 256 GCM failed";				}			};			class aes_256_gcm_context : virtual public base			{			public:				aes_256_gcm_context(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "AES 256 GCM failed creating new context";				}			};			class aes_256_gcm_init : virtual public base			{			public:				aes_256_gcm_init(const std::string&whre, const std::string&when) : base(whre, when) { };				const std::string what() const noexcept override				{					return "AES 256 GCM failed initialize";				}			};		}	}}
#include <string>#include <functional>#include <string>#include <sstream>#include <algorithm>namespace Cout{	namespace Core	{		namespace Utils		{			//  \0    ,  			static void rtrim_null(std::string& str);			static void replace(std::string & str, const std::string & substring, const std::string & rstr);			static std::string to_string(int x);			static std::string to_string(unsigned int x);			static std::string to_string(long x);			static std::string to_string(unsigned long x);			static std::string to_string(long long x);			static std::string to_string(unsigned long long x);			static std::string to_string(float x);			static std::string to_string(double x);			static std::string to_string(long double x);			static std::string to_string(const char *x);			static std::string to_string(const std::string &x);			template<typename T>			std::string to_string(const T &t);			// correct only for ASCII symbols			static unsigned char* StringToUnsignedChar(const std::string& strIn);		};		void Utils::rtrim_null(std::string& str) {			str.erase(std::find_if(str.rbegin(), str.rend(), [](int character) {				return '\0' != character;			}).base(), str.end());		}		void Utils::replace(std::string & str, const std::string & substring, const std::string & rstr)		{			size_t pos = 0;			while ((pos = str.find(substring, pos + rstr.size())) != std::string::npos)			{				str.replace(pos, rstr.size(), rstr);			}		}		unsigned char* Utils::StringToUnsignedChar(const std::string& strIn)		{			size_t length = strIn.size();			unsigned char * temp = new unsigned char[length];			for (int i = 0; i < length; ++i)			{				temp[i] = static_cast<unsigned char>(strIn[i]);			}			return temp;		}		template<typename T>		std::string Utils::to_string(const T &t)		{			std::stringstream ss;			ss << t;			return ss.str();		}		std::string Utils::to_string(int x)		{			return std::to_string(x);		}		std::string Utils::to_string(unsigned int x)		{			return std::to_string(x);		}		std::string Utils::to_string(long x)		{			return std::to_string(x);		}		std::string Utils::to_string(unsigned long x)		{			return std::to_string(x);		}		std::string Utils::to_string(long long x)		{			return std::to_string(x);		}		std::string Utils::to_string(unsigned long long x)		{			return std::to_string(x);		}		std::string Utils::to_string(float x)		{			return std::to_string(x);		}		std::string Utils::to_string(double x)		{			return std::to_string(x);		}		std::string Utils::to_string(long double x)		{			return std::to_string(x);		}		std::string Utils::to_string(const char *x)		{			return std::string(x);		}		std::string Utils::to_string(const std::string& x)		{			return x;		}	}}
#include <string>#include <functional>#include <string>namespace Cout{	namespace Core	{		namespace Logging		{			struct log_line			{				log_line(const char* lable);				log_line(const std::string& lable);				const std::string Formating(const std::string&);				const std::string lable;			};		}	}}
Cout::Core::Logging::log_line::log_line(const char* l) :	lable(l) { }Cout::Core::Logging::log_line::log_line(const std::string& l) :	lable(l) { }const std::string Cout::Core::Logging::log_line::Formating(const std::string& data){	return Utils::to_string(lable) + " " + data;}
#include <string>#include <functional>namespace Cout{	namespace Core	{		namespace Logging		{			class Log : private log_line			{			public:				Log(const std::string& lable);				virtual const std::string log(const std::string& data);			};		}	}}
Cout::Core::Logging::Log::Log(const std::string& lable)	: log_line(lable) {}const std::string Cout::Core::Logging::Log::log(const std::string& data){	return Formating(data);}
namespace Cout{	namespace Core	{		namespace Logging		{			class ILogger			{			private:				Log* _info;				Log* _warn;				Log* _err;			public:				ILogger(std::function<void(const std::string&)> c,					Log* info_label,					Log* warn_label,					Log* err_label);				void Info(const std::string& log);				void Warning(const std::exception& ex);				void Warning(const Cout::Exceptions::base&);				void Error(const std::string& what, const std::string& where);				void Error(const Cout::Exceptions::base&);				void Error(const std::exception&);				void Error(const Cout::Exceptions::base&, const std::string& what, const std::string& where);			private:				const std::function<void(const std::string&)> callback;			};		}	}}
Cout::Core::Logging::ILogger::ILogger(std::function<void(const std::string&)> c,	Log* info,	Log* warn,	Log* err) :	_info(info),	_warn(warn),	_err(err),	callback(c) {}void Cout::Core::Logging::ILogger::Warning(const std::exception& ex){	callback(_warn->log(Exceptions::Core::undefined(ex).log()));}void Cout::Core::Logging::ILogger::Warning(const Cout::Exceptions::base& ex){	callback(_warn->log(ex.log()));}void Cout::Core::Logging::ILogger::Error(const std::string& what, const std::string& where){	Error(Exceptions::Core::undefined(what, where));}void Cout::Core::Logging::ILogger::Error(const Cout::Exceptions::base& ex){	callback(_err->log(ex.log()));}void Cout::Core::Logging::ILogger::Error(const std::exception& ex){	callback(_err->log(Exceptions::Core::undefined(ex).log()));}void Cout::Core::Logging::ILogger::Error(const Cout::Exceptions::base& ex, const std::string& what, const std::string& where){	callback(_err->log(ex.log(what, where)));}void Cout::Core::Logging::ILogger::Info(const std::string& log){	callback(_info->log(log));}
namespace Cout{	namespace Core	{		namespace Logging		{			class Logger : public ILogger			{			public:				Logger(std::function<void(const std::string&)> c);			};		}	}}
namespace Cout{	namespace Core	{		namespace Pattern		{			/*				Facade class provides a simple interface for complex logic of one or				several subsystems.Facade delegates customer requests to relevant				objects within the subsystem.The facade is also responsible for managing their life				cycle.All this protects the client from the unwanted complexity of the subsystem.			*/			template<class Component>			class Facade			{			protected:				Component *_component;			public:				Facade() : _component(new Component) { }				Facade(Component *real_subject) : _component(real_subject) { }				~Facade()				{					if (_component)						delete _component;				}			};		}	}}
#include <functional>namespace Cout{	namespace Core	{		namespace Logging		{			class Warn : public Log			{			public:				Warn(const std::string&);				Warn();				const std::string log(const std::string& text) override;			};		}	}}
Cout::Core::Logging::Warn::Warn(const std::string&pre_lable) : Log(pre_lable + "[WARN]") { }Cout::Core::Logging::Warn::Warn() : Log("[WARN]") { }const std::string Cout::Core::Logging::Warn::log(const std::string& text){	return Log::log("\n" + text);}
#include <functional>namespace Cout{	namespace Core	{		namespace Logging		{			class Info : public Log			{			public:				Info(const std::string&);				Info();			};		}	}}
Cout::Core::Logging::Info::Info(const std::string&pre_lable) : Log(pre_lable + "[INFO]") { }Cout::Core::Logging::Info::Info() : Log("[INFO]") { }
#include <string>#include <functional>namespace Cout{	namespace Core	{		namespace Logging		{			class Error : public Log			{			public:				Error(const std::string&);				Error();				const std::string log(const std::string& text) override;			};		}	}}
Cout::Core::Logging::Error::Error(const std::string&pre_lable) : Log(pre_lable + "[ERROR]") { }Cout::Core::Logging::Error::Error() : Log("[ERROR]") { }const std::string Cout::Core::Logging::Error::log(const std::string& text){	return Log::log("\n" + text);}
Cout::Core::Logging::Logger::Logger(std::function<void(const std::string&)> c) :		ILogger(c, new Logging::Info, new Logging::Warn, new Logging::Error) {}
#ifdef INDEBUG#include <iostream>namespace Cout{	namespace Core	{		namespace Logging		{			class DebugLogger			{			private:				static ILogger* _logger;			public:				static void Info(const std::string& log);				static void Warning(const Cout::Exceptions::base&);				static void Error(const Cout::Exceptions::base&);			};		}	}}#define DEBUG_LOG(log_level, log) if(log_level <= LOG_LEVEL) Core::Logging::DebugLogger::Info(log);#define DEBUG_ERR(ex) Core::Logging::DebugLogger::Error(ex);#else#define DEBUG_LOG(log_level, log)#define DEBUG_ERR(while_msg, what, when)#endif
namespace Cout{	namespace Core	{		namespace Logging		{			class DebugError : public Error			{			public:				DebugError();			};		}	}}
Cout::Core::Logging::DebugError::DebugError() : Error("[DEBUG]") { }
namespace Cout{	namespace Core	{		namespace Logging		{			class DebugInfo : public Info			{			public:				DebugInfo();			};		}	}}
Cout::Core::Logging::DebugInfo::DebugInfo() : Info("[DEBUG]") { }
namespace Cout{	namespace Core	{		namespace Logging		{			class DebugWarn : public Warn			{			public:				DebugWarn();			};		}	}}
Cout::Core::Logging::DebugWarn::DebugWarn() : Warn("[DEBUG]") { }
#ifdef INDEBUGCout::Core::Logging::ILogger* Cout::Core::Logging::DebugLogger::_logger = new Cout::Core::Logging::ILogger(	[](const std::string& text) {	std::cout << text << std::endl; }, new DebugInfo, new DebugWarn, new DebugError);void Cout::Core::Logging::DebugLogger::Info(const std::string& log){	_logger->Info(log);}void Cout::Core::Logging::DebugLogger::Warning(const Cout::Exceptions::base& ex){	_logger->Warning(ex);}void Cout::Core::Logging::DebugLogger::Error(const Cout::Exceptions::base& ex){	_logger->Error(ex);}#endif
Cout::Encryption::OpenSSL::OpenSSL(){	ctx = NULL;	ssl = NULL;	DEBUG_LOG(3, "Initializing openssl");	SSL_library_init();	SSL_load_error_strings();	ctx = SSL_CTX_new(SSLv23_client_method());	if (ctx == NULL)		throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl invalid context");}Cout::Encryption::OpenSSL::~OpenSSL(){	if (ssl != NULL)	{		SSL_shutdown(ssl);  // send SSL/TLS close_notify		SSL_free(ssl);		ssl = NULL;	}	if (ctx != NULL)	{		SSL_CTX_free(ctx);		ctx = NULL;		ERR_remove_state(0);		ERR_free_strings();		EVP_cleanup();		CRYPTO_cleanup_all_ex_data();	}}
namespace Cout{	namespace Network	{		namespace Protocol		{			class IProtocol			{			public:				virtual void Connect(const std::string& host, unsigned short port) = 0;				virtual void Disconnect() = 0;				virtual void Send() = 0;				virtual void Receive() = 0;			};		}	}}
#ifndef WINAPI#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#endif#pragma comment(lib, "ws2_32.lib")#include <string>namespace Cout{	namespace Network	{		class Sockets		{		public:			Sockets();			~Sockets();			void Connect(const std::string& host, unsigned short port);			void Disconnect();			void Send(const Binary&);			Binary Receive();		protected:			enum type			{				tcp = SOCK_STREAM,				udp = SOCK_DGRAM,				raw = SOCK_RAW			};			enum address_family			{				inet = AF_INET,				local = AF_UNIX			};			bool isConnected;			static const int BUFFER_SIZE = 10240;			static const int TIMEOUT = 3 * 60;			std::string GetLocalName() const;			SOCKET hSocket;		};	}}
Cout::Network::Sockets::Sockets() : hSocket(INVALID_SOCKET), isConnected(false){	DEBUG_LOG(3, "Initializing WinSocksAPI");	WSADATA wsaData;	WORD wVer = MAKEWORD(2, 2);	if (WSAStartup(wVer, &wsaData) != NO_ERROR)		throw Cout::Network::Protocol::Exceptions::wsa::startup(WHERE, "WSA initializating");	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2)	{		WSACleanup();		throw Cout::Network::Protocol::Exceptions::wsa::version(WHERE, "WSA initializating");;	}}Cout::Network::Sockets::~Sockets(){	WSACleanup();}std::string Cout::Network::Sockets::GetLocalName() const{	char hostname[255];	if (gethostname((char *)&hostname, 255) == SOCKET_ERROR)		throw Cout::Network::Protocol::Exceptions::wsa::hostname(WHERE, "get local hostname");;	return hostname;}void Cout::Network::Sockets::Connect(const std::string& host, unsigned short port){	if (hSocket != INVALID_SOCKET)		throw Cout::Network::Protocol::Exceptions::wsa::already_connect(WHERE, "connect failed");	DEBUG_LOG(3, "Sockets connect");	unsigned short nPort = 0;	LPSERVENT lpServEnt;	SOCKADDR_IN sockAddr;	unsigned long ul = 1;	fd_set fdwrite, fdexcept;	timeval timeout;	int res = 0;	timeout.tv_sec = TIMEOUT;	timeout.tv_usec = 0;	hSocket = INVALID_SOCKET;	DEBUG_LOG(3, "Creating new socket");	if ((hSocket = socket(address_family::inet, type::tcp, 0)) == INVALID_SOCKET)		throw Cout::Network::Protocol::Exceptions::wsa::invalid_socket(WHERE, "connecting on sockets");	DEBUG_LOG(3, "Convert the byte representation of a port to the network byte order");	if (port != 0)		nPort = htons(port);	else	{		lpServEnt = getservbyname("mail", 0);		if (lpServEnt == NULL)			nPort = htons(25);		else			nPort = lpServEnt->s_port;	}	DEBUG_LOG(3, "Fill the server structure");	sockAddr.sin_family = AF_INET;	sockAddr.sin_port = nPort;	if ((sockAddr.sin_addr.s_addr = inet_addr(host.c_str())) == INADDR_NONE)	{		LPHOSTENT hostent;		hostent = gethostbyname(host.c_str());		if (hostent)			memcpy(&sockAddr.sin_addr, hostent->h_addr_list[0], hostent->h_length);		else		{			closesocket(hSocket);			throw Cout::Network::Protocol::Exceptions::wsa::gethostby_name_addr(WHERE, "connecting on sockets");		}	}	DEBUG_LOG(3, "Set the socket to non-blocking mode");	if (ioctlsocket(hSocket, FIONBIO, (unsigned long*)&ul) == SOCKET_ERROR)	{		closesocket(hSocket);		throw Cout::Network::Protocol::Exceptions::wsa::ioctlsocket(WHERE, "connecting on sockets");	}	DEBUG_LOG(3, "Connect to the server");	if (connect(hSocket, (LPSOCKADDR)&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR)	{		if (WSAGetLastError() != WSAEWOULDBLOCK)		{			closesocket(hSocket);			throw Cout::Network::Protocol::Exceptions::wsa::connect(WHERE, "connecting on sockets");		}	}	DEBUG_LOG(3, "Check connection");	while (true)	{		FD_ZERO(&fdwrite);		FD_ZERO(&fdexcept);		FD_SET(hSocket, &fdwrite);		FD_SET(hSocket, &fdexcept);		if ((res = select(static_cast<int>(hSocket) + 1, NULL, &fdwrite, &fdexcept, &timeout)) == SOCKET_ERROR)		{			closesocket(hSocket);			throw Cout::Network::Protocol::Exceptions::wsa::select(WHERE, "selecting sockets");;		}		if (!res)		{			closesocket(hSocket);			throw Cout::Network::Protocol::Exceptions::wsa::select_timeout(WHERE, "connecting on sockets");		}		if (res && FD_ISSET(hSocket, &fdwrite))			break;		if (res && FD_ISSET(hSocket, &fdexcept))		{			closesocket(hSocket);			throw Cout::Network::Protocol::Exceptions::wsa::select(WHERE, "connecting on sockets");		}	} // while	FD_CLR(hSocket, &fdwrite);	FD_CLR(hSocket, &fdexcept);	isConnected = true;	DEBUG_LOG(3, "Connection with server successfully established");}void Cout::Network::Sockets::Disconnect(){	DEBUG_LOG(3, "Sockets disconnected");	if (hSocket)	{		closesocket(hSocket);	}	isConnected = false;	hSocket = INVALID_SOCKET;}#include <iostream>void Cout::Network::Sockets::Send(const Cout::Binary& SendBuf){	int res;	fd_set fdwrite;	timeval time;	time.tv_sec = TIMEOUT;	time.tv_usec = 0;	if (!SendBuf.size())		throw Cout::Network::Protocol::Exceptions::wsa::sendbuf_is_empty(WHERE, "send by sockets");	if (hSocket == INVALID_SOCKET)		throw Cout::Network::Protocol::Exceptions::wsa::connection_closed(WHERE, "send by sockets");	FD_ZERO(&fdwrite);	FD_SET(hSocket, &fdwrite);	if ((res = select(static_cast<int>(hSocket) + 1, NULL, &fdwrite, NULL, &time)) == SOCKET_ERROR)	{		FD_CLR(hSocket, &fdwrite);		throw Cout::Network::Protocol::Exceptions::wsa::select(WHERE, "send by sockets");	}	if (!res)	{		//timeout		FD_CLR(hSocket, &fdwrite);		throw Cout::Network::Protocol::Exceptions::wsa::server_not_responding(WHERE, "send by sockets");	}	if (res && FD_ISSET(hSocket, &fdwrite))	{		res = send(hSocket, SendBuf.data(), static_cast<int>(SendBuf.size()), 0);		if (res == SOCKET_ERROR || res == 0)		{			FD_CLR(hSocket, &fdwrite);			throw Cout::Network::Protocol::Exceptions::wsa::send(WHERE, "send by sockets");		}	}	FD_CLR(hSocket, &fdwrite);}Cout::Binary Cout::Network::Sockets::Receive(){	DEBUG_LOG(3, "Receiving data using sockets");	SignedByte buffer[BUFFER_SIZE];	std::string RecvBuf;	int res = 0;	fd_set fdread;	timeval time;	time.tv_sec = TIMEOUT;	time.tv_usec = 0;	FD_ZERO(&fdread);	FD_SET(hSocket, &fdread);	if ((res = select(static_cast<int>(hSocket) + 1, &fdread, NULL, NULL, &time)) == SOCKET_ERROR)	{		FD_CLR(hSocket, &fdread);		throw Cout::Network::Protocol::Exceptions::wsa::select(WHERE, "sockets select");	}	if (!res)	{		//timeout		FD_CLR(hSocket, &fdread);		throw Cout::Network::Protocol::Exceptions::wsa::server_not_responding(WHERE, "sockets select");	}	if (FD_ISSET(hSocket, &fdread))	{		res = recv(hSocket, buffer, BUFFER_SIZE, 0);		if (res == SOCKET_ERROR)		{			FD_CLR(hSocket, &fdread);			throw Cout::Network::Protocol::Exceptions::wsa::recv(WHERE, "receiving data over sockets failed");		}	}	FD_CLR(hSocket, &fdread);	if (res == 0)	{		isConnected = false;		throw Cout::Network::Protocol::Exceptions::wsa::connection_closed(WHERE, "receiving data over sockets");	}	return { buffer, static_cast<size_t>(res) };}
namespace Cout{	namespace Network	{		namespace Protocol		{			class Raw : public Sockets, public IProtocol			{			public:				Raw();				virtual ~Raw()				{					if (isConnected)						Disconnect();				}				void Connect(const std::string& host, unsigned short port) override;				void Disconnect() override;				void Send() override;				void Receive() override;			protected:				Binary SendBuf;				Binary RecvBuf;			};		}	}}
Cout::Network::Protocol::Raw::Raw() : Sockets(){	DEBUG_LOG(3, "Initializing raw socks protocol");}void Cout::Network::Protocol::Raw::Connect(const std::string& host, unsigned short port){	Sockets::Connect(host, port);}void Cout::Network::Protocol::Raw::Disconnect(){	Sockets::Disconnect();}void Cout::Network::Protocol::Raw::Send(){	if (!isConnected)		Exceptions::wsa::connection_closed(WHERE, "before attempted to sending data");	Sockets::Send(SendBuf);	SendBuf.clear();}void Cout::Network::Protocol::Raw::Receive(){	if (!isConnected)		Exceptions::wsa::connection_closed(WHERE, "before attempted to receive data");	RecvBuf = Sockets::Receive();}
#include <utility>namespace Cout{	namespace Network	{		namespace Protocol		{			class Secured : public Raw, private Encryption::OpenSSL			{			public:				enum Type				{					TLS,					SSL				};				Secured();				virtual ~Secured() {};				void Connect(const std::string& host, unsigned short port) override;				void Disconnect() override;				void Send() override;				void Receive() override;				void SetUpSSL();			protected:				bool isSecured;			};		}	}}
Cout::Network::Protocol::Secured::Secured() : isSecured(false) {};void Cout::Network::Protocol::Secured::Receive(){	if (!isSecured)	{		Raw::Receive();		return;	}	int res = 0;	int offset = 0;	fd_set fdread;	fd_set fdwrite;	timeval time;	int read_blocked_on_write = 0;	time.tv_sec = TIMEOUT;	time.tv_usec = 0;	bool bFinish = false;	while (!bFinish)	{		FD_ZERO(&fdread);		FD_ZERO(&fdwrite);		FD_SET(hSocket, &fdread);		if (read_blocked_on_write)		{			FD_SET(hSocket, &fdwrite);		}		if ((res = select(static_cast<int>(hSocket) + 1, &fdread, &fdwrite, NULL, &time)) == SOCKET_ERROR)		{			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Network::Protocol::Exceptions::wsa::select(WHERE, "ssl receiving select");		}		if (!res)		{			//timeout			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Exceptions::wsa::server_not_responding(WHERE, "ssl receiving select");		}		if (FD_ISSET(hSocket, &fdread) || (read_blocked_on_write && FD_ISSET(hSocket, &fdwrite)))		{			while (true)			{				read_blocked_on_write = 0;				const int buff_len = 1024;				char buff[buff_len];				res = SSL_read(ssl, buff, buff_len);				int ssl_err = SSL_get_error(ssl, res);				if (ssl_err == SSL_ERROR_NONE)				{					if (offset + res > BUFFER_SIZE - 1)					{						FD_ZERO(&fdread);						FD_ZERO(&fdwrite);						isConnected = false;						throw Cout::Exceptions::Core::lack_of_memory(WHERE, "ssl receiving");					}					RecvBuf = buff;					offset += res;					RecvBuf[offset] = '\0';					if (SSL_pending(ssl))					{						continue;					}					else					{						bFinish = true;						break;					}				}				else if (ssl_err == SSL_ERROR_ZERO_RETURN)				{					bFinish = true;					break;				}				else if (ssl_err == SSL_ERROR_WANT_READ)				{					break;				}				else if (ssl_err == SSL_ERROR_WANT_WRITE)				{					/*						We get a WANT_WRITE if we're						trying to rehandshake and we block on						a write during that rehandshake.						We need to wait on the socket to be						writeable but reinitiate the read						when it is					*/					read_blocked_on_write = 1;					break;				}				else				{					FD_ZERO(&fdread);					FD_ZERO(&fdwrite);					isConnected = false;					throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl receiving");				}			}		}	}	FD_ZERO(&fdread);	FD_ZERO(&fdwrite);	if (offset == 0)	{		isConnected = false;		throw Exceptions::wsa::connection_closed(WHERE, "ssl receiving");	}}void Cout::Network::Protocol::Secured::Send(){	if (!isSecured)	{		Raw::Send();		return;	}	size_t res;	fd_set fdwrite;	fd_set fdread;	timeval time;	int write_blocked_on_read = 0;	time.tv_sec = TIMEOUT;	time.tv_usec = 0;		FD_ZERO(&fdwrite);	FD_ZERO(&fdread);	FD_SET(hSocket, &fdwrite);	if (write_blocked_on_read)	{		FD_SET(hSocket, &fdread);	}	if ((res = select(static_cast<int>(hSocket) + 1, &fdread, &fdwrite, NULL, &time)) == SOCKET_ERROR)	{		FD_ZERO(&fdwrite);		FD_ZERO(&fdread);		isConnected = false;		throw Exceptions::wsa::select(WHERE, "ssl send select");	}	if (!res)	{		//timeout		FD_ZERO(&fdwrite);		FD_ZERO(&fdread);		isConnected = false;		throw Exceptions::wsa::server_not_responding(WHERE, "ssl send select");	}	if (FD_ISSET(hSocket, &fdwrite) || (write_blocked_on_read && FD_ISSET(hSocket, &fdread)))	{		write_blocked_on_read = 0;		// Try to write		res = SSL_write(ssl, SendBuf.data(), static_cast<int>(SendBuf.size()));		SendBuf.clear();		int code = SSL_get_error(ssl, static_cast<int>(res));		switch (code)		{			// We wrote something		case SSL_ERROR_NONE:			break;			// We would have blocked 		case SSL_ERROR_WANT_WRITE:			break;			/*			   We get a WANT_READ if we're			   trying to rehandshake and we block on			   write during the current connection.			   We need to wait on the socket to be readable			   but reinitiate our write when it is			*/		case SSL_ERROR_WANT_READ:			write_blocked_on_read = 1;			break;		case SSL_ERROR_ZERO_RETURN:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_zero_return(WHERE, "ssl send");			break;		case SSL_ERROR_WANT_CONNECT:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_zero_return(WHERE, "ssl send");			break;		case SSL_ERROR_WANT_ACCEPT:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_accept(WHERE, "ssl send");			break;		case SSL_ERROR_WANT_X509_LOOKUP:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_lookup(WHERE, "ssl send");			break;		case SSL_ERROR_WANT_ASYNC:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_async(WHERE, "ssl send");			break;		case SSL_ERROR_SYSCALL:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_syscall(WHERE, "ssl send");			break;		default:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl send");		}	}	FD_ZERO(&fdwrite);	FD_ZERO(&fdread);}void Cout::Network::Protocol::Secured::Connect(const std::string& host, unsigned short port){	if (!isConnected)		Raw::Connect(host, port);}void Cout::Network::Protocol::Secured::SetUpSSL(){	if (ctx == NULL)		throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl invalid context");	ssl = SSL_new(ctx);	if (ssl == NULL)		throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl new failed");	SSL_set_fd(ssl, (int)hSocket);	SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);	int res = 0;	fd_set fdwrite;	fd_set fdread;	int write_blocked = 0;	int read_blocked = 0;	timeval time;	time.tv_sec = TIMEOUT;	time.tv_usec = 0;	while (1)	{		FD_ZERO(&fdwrite);		FD_ZERO(&fdread);		if (write_blocked)			FD_SET(hSocket, &fdwrite);		if (read_blocked)			FD_SET(hSocket, &fdread);		if (write_blocked || read_blocked)		{			write_blocked = 0;			read_blocked = 0;			if ((res = select(static_cast<int>(hSocket) + 1, &fdread, &fdwrite, NULL, &time)) == SOCKET_ERROR)			{				FD_ZERO(&fdwrite);				FD_ZERO(&fdread);				isConnected = false;				throw Exceptions::wsa::select(WHERE, "ssl connect select");			}			if (!res)			{				//timeout				FD_ZERO(&fdwrite);				FD_ZERO(&fdread);				isConnected = false;				throw Exceptions::wsa::server_not_responding(WHERE, "ssl connect select");			}		}		res = SSL_connect(ssl);		switch (SSL_get_error(ssl, res))		{		case SSL_ERROR_NONE:			FD_ZERO(&fdwrite);			FD_ZERO(&fdread);			isSecured = true;			return;			break;		case SSL_ERROR_WANT_WRITE:			write_blocked = 1;			break;		case SSL_ERROR_WANT_READ:			read_blocked = 1;			break;		case SSL_ERROR_ZERO_RETURN:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_zero_return(WHERE, "ssl connect");			break;		case SSL_ERROR_WANT_CONNECT:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_zero_return(WHERE, "ssl connect");			break;		case SSL_ERROR_WANT_ACCEPT:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_accept(WHERE, "ssl connect");			break;		case SSL_ERROR_WANT_X509_LOOKUP:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_lookup(WHERE, "ssl connect");			break;		case SSL_ERROR_WANT_ASYNC:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_want_async(WHERE, "ssl connect");			break;		case SSL_ERROR_SYSCALL:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_syscall(WHERE, "ssl connect");			break;		default:			FD_ZERO(&fdread);			FD_ZERO(&fdwrite);			isConnected = false;			throw Cout::Encryption::Exceptions::openssl_problem(WHERE, "ssl connect");		}	}}void Cout::Network::Protocol::Secured::Disconnect(){	Raw::Disconnect();	isSecured = false;}
#include <map>namespace Cout{	namespace Network	{		namespace Protocol		{			namespace SMTP			{				struct Server				{				public:					enum ID					{						UNDEFINED,						GMAIL_TLS,						GMAIL_SSL,						HOTMAIL_TSL,						AOL_TLS,						YAHOO_SSL					};					Server();					Server(Secured::Type s, const char* h, unsigned short p);					inline const std::string GetSecurity() const noexcept;					const char* host;					unsigned short port;					Secured::Type sec;				};			}		}	}}
Cout::Network::Protocol::SMTP::Server::Server() : sec(),	host(""),	port(0) {};Cout::Network::Protocol::SMTP::Server::Server(Secured::Type s, const char* h, unsigned short p)	: sec(s), host(h), port(p) {};inline const std::string Cout::Network::Protocol::SMTP::Server::GetSecurity() const noexcept{	return sec == Secured::Type::SSL ? "ssl" : "tls";}
#include <vector>#include <string>#define MSG_SIZE_IN_MB	25		// the maximum size of the message with all attachments#define COUNTER_VALUE	100		// how many times program will try to receive datanamespace Cout{	namespace Network	{		namespace Protocol		{			namespace SMTP			{				class ESMTPSA : public Secured, public Server				{				public:					ESMTPSA();					~ESMTPSA();					void Connect(const std::string& host, unsigned short port) override;					void Disconnect() override;					void Send() override;					void Receive() override;					const std::string& GetLogin() const noexcept;					const std::string& GetPassword() const noexcept;					void SetLogin(const std::string& login);					void SetPassword(const std::string& pass);					void Send(MAIL* mail);				protected:					struct Creds					{						std::string login;						std::string password;					};					Creds credentials;					const std::string m_sLocalHostName;					void Handshake();					bool isRetCodeValid(int validCode) const;					bool IsCommandSupported(const std::string& response, const std::string& command) const;					int SmtpXYZdigits() const;					void SetUpSSL();					void SetUpTLS();					using COMMAND = const unsigned short int;					void Command(COMMAND command);					static const COMMAND INIT = 1;				private:					bool pendingTransaction;					MAIL* mail;					const unsigned short BUFFER_SIZE = 10240;					void Auth();					bool isAuthRequired = true;					static const COMMAND AUTHPLAIN = 11;					static const COMMAND AUTHLOGIN = 12;					static const COMMAND AUTHCRAMMD5 = 13;					static const COMMAND AUTHDIGESTMD5 = 14;					void AuthLogin();					void AuthPlain();					void CramMD5();					void DigestMD5();					static const COMMAND EHLO = 2;					static const COMMAND MAILFROM = 3;					static const COMMAND RCPTTO = 4;					static const COMMAND DATA = 5;					static const COMMAND DATABLOCK = 6;					static const COMMAND DATAEND = 7;					static const COMMAND QUIT = 8;					static const COMMAND STARTTLS = 10;					void Init();					void Ehlo();					void Starttls();					void MailFrom();					void RCPTto();					void Data();					void Datablock();					void DataEnd();					void Quit();				};			}		}	}}
#include <functional>#include <vector>#include <string>#include <set>namespace Cout{	namespace Core	{		namespace Filesystem		{			class Explorer : public Pattern::Facade<ContextMenu>			{			public:				Explorer() : _path(fs::current_path()) {}				Explorer(const Path& p) : _path(p) {}				bool exist(const Path& p);				bool isdir(const Path& p);				size_t size(const Path& p);				Path temp();				Collection listing(const Path& dir) const;				void move(const Path& source, const Path& dest);				void copy(const Path& source, const Path& dest);				void remove(const Path& p);				void mkdir(const Path& p);				void mkfile(const Path& p);				using ReadCallback = ContextMenu::ReadCallback;				void read(const Path& file, size_t block_size, ReadCallback callback);				Binary read(const Path& file);				void write(const Path& file, const Binary& data);				Path& path();				Collection find(const Path& base_dir, const std::set<std::string>& files, int max_level, int level = 0);				Collection find(const Path& base_dir, const std::string& file, int max_level, int level = 0);				void cd(const Path&);			private:				Path _path;			};		}	}}
#include <algorithm>bool Cout::Core::Filesystem::Explorer::isdir(const Path& p){	return fs::is_directory(p);}void Cout::Core::Filesystem::Explorer::write(const Path& path, const Cout::Binary& data){	WriteableFile file(path);	_component->write(file, data);}bool Cout::Core::Filesystem::Explorer::exist(const Path& p){	return _component->exist(Descryptor(p));}size_t Cout::Core::Filesystem::Explorer::size(const Path& p){	if (!exist(p))		throw Cout::Exceptions::Core::file_not_exist(WHERE, "explorer checking size");	if (isdir(p))	{		return _component->size(DirDescryptor(p));	}	else	{		return _component->size(FileDescryptor(p));	}}Cout::Core::Filesystem::Collection Cout::Core::Filesystem::Explorer::listing(const Path& dir) const{	return _component->listing(DirDescryptor(dir));}Cout::Binary Cout::Core::Filesystem::Explorer::read(const Path& fname){	auto file = ReadableFile(fname);	return _component->read(file);}void Cout::Core::Filesystem::Explorer::read(const Path& fname, size_t block_size, ReadCallback callback){	auto file = ReadableFile(fname);	_component->read(file, block_size, callback);}Cout::Core::Filesystem::Path Cout::Core::Filesystem::Explorer::temp(){	return fs::temp_directory_path();}void Cout::Core::Filesystem::Explorer::move(const Path& source, const Path& dest){	if (isdir(source))	{		auto dir = MoveableDir{ source };		_component->move(dir, { dest });	}	else	{		auto file = MoveableFile{ source };		_component->move(file, { dest });	}}void Cout::Core::Filesystem::Explorer::copy(const Path& source, const Path& dest){	if (isdir(source))	{		_component->copy(CopyableDir{ source }, { dest });	}	else	{		_component->copy(CopyableFile{ source }, { dest });	}}Cout::Core::Filesystem::Collection Cout::Core::Filesystem::Explorer::find(const Path& base_dir, const std::set<std::string>& files, int max_level, int level){	Collection res;	if (max_level == level)		return res;	auto list = listing(base_dir);	for (auto& file : list.files)	{		if (files.count(file.path().filename().string()))			res.files.push_back(file);	}	for (auto& dir : list.dirs)	{		if (files.count(dir.path().filename().string()))			res.dirs.push_back(dir);		res.append(find(base_dir, files, max_level, level + 1));	}	return res;}Cout::Core::Filesystem::Collection Cout::Core::Filesystem::Explorer::find(const Path& base_dir, const std::string& fnfile, int max_level, int level){	Collection res;	if (max_level == level)		return res;	auto list = listing(base_dir);	for (auto& file : list.files)	{		if (fnfile == file.path().filename().string())			res.files.push_back(file);	}	for (auto& dir : list.dirs)	{		if (fnfile == dir.path().filename().string())			res.dirs.push_back(dir);		res.append(find(base_dir, fnfile, max_level, level + 1));	}	return res;}void Cout::Core::Filesystem::Explorer::remove(const Path& p){	auto d = Descryptor(p);	if (!_component->exist(d))		throw Cout::Exceptions::Core::file_not_exist(WHERE, "explorer deleting unexisted file or dir");	_component->remove(d);}void Cout::Core::Filesystem::Explorer::mkdir(const Path& p){	_component->create(DirDescryptor{ p });}void Cout::Core::Filesystem::Explorer::mkfile(const Path& p){	_component->create(FileDescryptor{ p });}Cout::Core::Filesystem::Path& Cout::Core::Filesystem::Explorer::path(){	return _path;}void Cout::Core::Filesystem::Explorer::cd(const Path& p){	if (!exist(p))		throw Cout::Exceptions::Core::dir_not_exist(WHERE, "explorer change dir");	if(!isdir(p))		throw Cout::Exceptions::Core::dir_not_exist(WHERE, "explorer change dir");	_path = p;}
#include <string>#include <vector>namespace Cout{	namespace Encryption	{		namespace Algorithm		{			class IAlgorithm			{			public:				// decode and encode				virtual UnsignedBinary Encode(const UnsignedBinary& data_to_encode) = 0;				virtual UnsignedBinary Decode(const UnsignedBinary& encoded_string) = 0;			};		}	}}
namespace Cout{	namespace Encryption	{		namespace Algorithm		{			class Base64 : public IAlgorithm			{			private:				// check for that is base64-char				static inline bool check(unsigned char c);			public:				// decode and encode base64				UnsignedBinary Encode(const UnsignedBinary& data_to_encode) override;				UnsignedBinary Decode(const UnsignedBinary& encoded_string) override;			private:				static const std::string base64_chars;			};		}	}}
const std::string Cout::Encryption::Algorithm::Base64::base64_chars ="ABCDEFGHIJKLMNOPQRSTUVWXYZ""abcdefghijklmnopqrstuvwxyz""0123456789+/";inline bool Cout::Encryption::Algorithm::Base64::check(unsigned char c){	return (isalnum(c) || (c == '+') || (c == '/'));}Cout::UnsignedBinary Cout::Encryption::Algorithm::Base64::Encode(const Cout::UnsignedBinary& data_to_encode){	Cout::UnsignedBinary res;	auto ptr = data_to_encode.data();	auto length = data_to_encode.size();	unsigned int index = 0;	int i = 0, j = 0;	unsigned char char_array_3[3], char_array_4[4];	while (length--)	{		char_array_3[i++] = *(ptr++);		if (i == 3)		{			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);			char_array_4[3] = char_array_3[2] & 0x3f;			for (i = 0; (i < 4); i++)			{				res.push_back(base64_chars[char_array_4[i]]);				index++;			}			i = 0;		}	}	if (i)	{		for (j = i; j < 3; j++)			char_array_3[j] = '\0';		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);		char_array_4[3] = char_array_3[2] & 0x3f;		for (j = 0; (j < i + 1); j++)		{			res.push_back(base64_chars[char_array_4[j]]);			index++;		}		while ((i++ < 3))		{			res.push_back('=');			index++;		}	}	return res;}Cout::UnsignedBinary Cout::Encryption::Algorithm::Base64::Decode(const Cout::UnsignedBinary& encoded_string){	Cout::UnsignedBinary res;	int i = 0, j = 0, in_ = 0;	auto length = encoded_string.size();	char char_array_4[4], char_array_3[3];	while (length-- && (encoded_string[in_] != '=') && check(encoded_string[in_]))	{		char_array_4[i++] = encoded_string[in_]; in_++;		if (i == 4) {			for (i = 0; i < 4; i++)				char_array_4[i] = static_cast<char>(base64_chars.find(char_array_4[i]));			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];			for (i = 0; (i < 3); i++)			{				res.push_back(char_array_3[i]);			}			i = 0;		}	}	if (i)	{		for (j = i; j < 4; j++)			char_array_4[j] = 0;		for (j = 0; j < 4; j++)			char_array_4[j] = static_cast<char>(base64_chars.find(char_array_4[j]));		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];		for (j = 0; (j < i - 1); j++)		{			res.push_back(char_array_3[j]);		}	}	return res;}
#include <string>#include <sstream>#include <ctime>namespace Cout{	namespace Network	{		namespace Protocol		{			namespace Authentication			{				namespace Method				{					std::string Plain(const std::string& login, const std::string& pass);					std::string Login(const std::string& credentials);					std::string CramMD5(const std::string& encoded_challenge, const std::string& login, const std::string& pass);					std::string DigestMD5(const std::string& encoded_challenge, const std::string& charset, const std::string& addr, const std::string& login, const std::string& pass);				}			};		}	}}
// MD5.CC - source code for the C++/object oriented translation and //          modification of MD5.// Translation and modification (c) 1995 by Mordechai T. Abzug // This translation/ modification is provided "as is," without express or // implied warranty of any kind.// The translator/ modifier does not claim (1) that MD5 will do what you think // it does; (2) that this translation/ modification is accurate; or (3) that // this software is "merchantible."  (Language for this disclaimer partially // copied from the disclaimer below)./* based on:   MD5.H - header file for MD5C.C   MDDRIVER.C - test driver for MD2, MD4 and MD5   Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. Allrights reserved.License to copy and use this software is granted provided that itis identified as the "RSA Data Security, Inc. MD5 Message-DigestAlgorithm" in all material mentioning or referencing this softwareor this function.License is also granted to make and use derivative works providedthat such works are identified as "derived from the RSA DataSecurity, Inc. MD5 Message-Digest Algorithm" in all materialmentioning or referencing the derived work.RSA Data Security, Inc. makes no representations concerning eitherthe merchantability of this software or the suitability of thissoftware for any particular purpose. It is provided "as is"without express or implied warranty of any kind.These notices must be retained in any copies of any part of thisdocumentation and/or software.*/#include <stdio.h>#include <fstream>#include <iostream>namespace Cout{	namespace Encryption	{		namespace Algorithm		{			class MD5			{			public:				// methods for controlled operation:				MD5();  // simple initializer				void  update(unsigned char *input, size_t input_length);				void  update(std::istream& stream);				void  update(FILE *file);				void  update(std::ifstream& stream);				void  finalize();				// constructors for special circumstances.  All these constructors finalize				// the MD5 context.				MD5(unsigned char *string); // digest string, finalize				MD5(std::istream& stream);       // digest stream, finalize				MD5(FILE *file);            // digest file, close, finalize				MD5(std::ifstream& stream);      // digest stream, close, finalize			  // methods to acquire finalized result				unsigned char    *raw_digest();  // digest as a 16-byte binary array				char *            hex_digest();  // digest as a 33-byte ascii-hex string				friend std::ostream&   operator<< (std::ostream&, MD5 context);			private:				// first, some types:				typedef unsigned       int uint4; // assumes integer is 4 words long				typedef unsigned short int uint2; // assumes short integer is 2 words long				typedef unsigned      char uint1; // assumes char is 1 word long			  // next, the private data:				uint4 state[4];				uint4 count[2];     // number of *bits*, mod 2^64				uint1 buffer[64];   // input buffer				uint1 digest[16];				uint1 finalized;				// last, the private methods, mostly static:				void init();               // called by all constructors				void transform(uint1 *buffer);  // does the real update work.  Note 														// that length is implied to be 64.				static void encode(uint1 *dest, uint4 *src, uint4 length);				static void decode(uint4 *dest, uint1 *src, uint4 length);				static void memcpy(uint1 *dest, uint1 *src, uint4 length);				static void memset(uint1 *start, uint1 val, uint4 length);				static inline uint4  rotate_left(uint4 x, uint4 n);				static inline uint4  F(uint4 x, uint4 y, uint4 z);				static inline uint4  G(uint4 x, uint4 y, uint4 z);				static inline uint4  H(uint4 x, uint4 y, uint4 z);				static inline uint4  I(uint4 x, uint4 y, uint4 z);				static inline void   FF(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,					uint4 s, uint4 ac);				static inline void   GG(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,					uint4 s, uint4 ac);				static inline void   HH(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,					uint4 s, uint4 ac);				static inline void   II(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,					uint4 s, uint4 ac);			};		}	}}
// MD5.CC - source code for the C++/object oriented translation and //          modification of MD5.// Translation and modification (c) 1995 by Mordechai T. Abzug // This translation/ modification is provided "as is," without express or // implied warranty of any kind.// The translator/ modifier does not claim (1) that MD5 will do what you think // it does; (2) that this translation/ modification is accurate; or (3) that // this software is "merchantible."  (Language for this disclaimer partially // copied from the disclaimer below)./* based on:   MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm   MDDRIVER.C - test driver for MD2, MD4 and MD5   Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. Allrights reserved.License to copy and use this software is granted provided that itis identified as the "RSA Data Security, Inc. MD5 Message-DigestAlgorithm" in all material mentioning or referencing this softwareor this function.License is also granted to make and use derivative works providedthat such works are identified as "derived from the RSA DataSecurity, Inc. MD5 Message-Digest Algorithm" in all materialmentioning or referencing the derived work.RSA Data Security, Inc. makes no representations concerning eitherthe merchantability of this software or the suitability of thissoftware for any particular purpose. It is provided "as is"without express or implied warranty of any kind.These notices must be retained in any copies of any part of thisdocumentation and/or software. */#include <assert.h>#include <string.h>#include <iostream>// MD5 simple initialization methodCout::Encryption::Algorithm::MD5::MD5() {	init();}// MD5 block update operation. Continues an MD5 message-digest// operation, processing another message block, and updating the// context.void Cout::Encryption::Algorithm::MD5::update(uint1 *input, size_t input_length) {	size_t input_index, buffer_index;	size_t buffer_space;                // how much space is left in buffer	if (finalized) {  // so we can't update!		std::cerr << "MD5::update:  Can't update a finalized digest!" << std::endl;		return;	}	// Compute number of bytes mod 64	buffer_index = (unsigned int)((count[0] >> 3) & 0x3F);	// Update number of bits	if ((count[0] += ((uint4)input_length << 3)) < ((uint4)input_length << 3))		count[1]++;	count[1] += ((uint4)input_length >> 29);	buffer_space = 64 - buffer_index;  // how much space is left in buffer	// Transform as many times as possible.	if (input_length >= buffer_space) { // ie. we have enough to fill the buffer	  // fill the rest of the buffer and transform		memcpy(buffer + buffer_index, input, static_cast<unsigned int>(buffer_space));		transform(buffer);		// now, transform each 64-byte piece of the input, bypassing the buffer		for (input_index = buffer_space; input_index + 63 < input_length;			input_index += 64)			transform(input + input_index);		buffer_index = 0;  // so we can buffer remaining	}	else		input_index = 0;     // so we can buffer the whole input	  // and here we do the buffering:	memcpy(buffer + buffer_index, input + input_index, static_cast<unsigned int>(input_length - input_index));}// MD5 update for files.// Like above, except that it works on files (and uses above as a primitive.)void Cout::Encryption::Algorithm::MD5::update(FILE *file) {	unsigned char buffer[1024];	size_t len;	while ((len = fread(buffer, 1, 1024, file)) != 0)		update(buffer, len);	fclose(file);}// MD5 update for istreams.// Like update for files; see above.void Cout::Encryption::Algorithm::MD5::update(std::istream& stream) {	unsigned char buffer[1024];	int len;	while (stream.good()) {		stream.read((char *)buffer, 1024); // note that return value of read is unusable.		len = (int)stream.gcount();		update(buffer, len);	}}// MD5 update for ifstreams.// Like update for files; see above.void Cout::Encryption::Algorithm::MD5::update(std::ifstream& stream) {	unsigned char buffer[1024];	int len;	while (stream.good()) {		stream.read((char *)buffer, 1024); // note that return value of read is unusable.		len = (int)stream.gcount();		update(buffer, len);	}}// MD5 finalization. Ends an MD5 message-digest operation, writing the// the message digest and zeroizing the context.void Cout::Encryption::Algorithm::MD5::finalize() {	unsigned char bits[8];	unsigned int index, padLen;	static uint1 PADDING[64] = {	  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	};	if (finalized) {		std::cerr << "MD5::finalize:  Already finalized this digest!" << std::endl;		return;	}	// Save number of bits	encode(bits, count, 8);	// Pad out to 56 mod 64.	index = (uint4)((count[0] >> 3) & 0x3f);	padLen = (index < 56) ? (56 - index) : (120 - index);	update(PADDING, padLen);	// Append length (before padding)	update(bits, 8);	// Store state in digest	encode(digest, state, 16);	// Zeroize sensitive information	memset(buffer, 0, sizeof(buffer));	finalized = 1;}Cout::Encryption::Algorithm::MD5::MD5(FILE *file) {	init();  // must be called be all constructors	update(file);	finalize();}Cout::Encryption::Algorithm::MD5::MD5(std::istream& stream) {	init();  // must called by all constructors	update(stream);	finalize();}Cout::Encryption::Algorithm::MD5::MD5(std::ifstream& stream) {	init();  // must called by all constructors	update(stream);	finalize();}unsigned char * Cout::Encryption::Algorithm::MD5::raw_digest() {	uint1 *s = new uint1[16];	if (!finalized) {		std::cerr << "MD5::raw_digest:  Can't get digest if you haven't " <<			"finalized the digest!" << std::endl;		return ((unsigned char*) "");	}	memcpy(s, digest, 16);	return s;}char * Cout::Encryption::Algorithm::MD5::hex_digest() {	int i;	char *s = new char[33];	::memset(s, 0, 33);	if (!finalized) {		std::cerr << "MD5::hex_digest:  Can't get digest if you haven't " <<			"finalized the digest!" << std::endl;		return s;	}	for (i = 0; i < 16; i++)		sprintf_s(s + i * 2, 33, "%02x", digest[i]);	s[32] = '\0';	return s;}std::ostream& operator<<(std::ostream &stream, Cout::Encryption::Algorithm::MD5 context) {	stream << context.hex_digest();	return stream;}// PRIVATE METHODS:void Cout::Encryption::Algorithm::MD5::init() {	finalized = 0;  // we just started!	// Nothing counted, so count=0	count[0] = 0;	count[1] = 0;	// Load magic initialization constants.	state[0] = 0x67452301;	state[1] = 0xefcdab89;	state[2] = 0x98badcfe;	state[3] = 0x10325476;}// Constants for MD5Transform routine.// Although we could use C++ style constants, defines are actually better,// since they let us easily evade scope clashes.#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21// MD5 basic transformation. Transforms state based on block.void Cout::Encryption::Algorithm::MD5::transform(uint1 block[64]) {	uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];	decode(x, block, 64);	assert(!finalized);  // not just a user error, since the method is private	/* Round 1 */	FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */	FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */	FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */	FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */	FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */	FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */	FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */	FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */	FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */	FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */	FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */	FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */	FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */	FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */	FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */	FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */   /* Round 2 */	GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */	GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */	GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */	GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */	GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */	GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */	GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */	GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */	GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */	GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */	GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */	GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */	GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */	GG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */	GG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */	GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */	/* Round 3 */	HH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */	HH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */	HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */	HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */	HH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */	HH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */	HH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */	HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */	HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */	HH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */	HH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */	HH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */	HH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */	HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */	HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */	HH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */	/* Round 4 */	II(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */	II(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */	II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */	II(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */	II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */	II(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */	II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */	II(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */	II(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */	II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */	II(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */	II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */	II(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */	II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */	II(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */	II(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */	state[0] += a;	state[1] += b;	state[2] += c;	state[3] += d;	// Zeroize sensitive information.	memset((uint1 *)x, 0, sizeof(x));}// Encodes input (UINT4) into output (unsigned char). Assumes len is// a multiple of 4.void Cout::Encryption::Algorithm::MD5::encode(uint1 *output, uint4 *input, uint4 len) {	unsigned int i, j;	for (i = 0, j = 0; j < len; i++, j += 4) {		output[j] = (uint1)(input[i] & 0xff);		output[j + 1] = (uint1)((input[i] >> 8) & 0xff);		output[j + 2] = (uint1)((input[i] >> 16) & 0xff);		output[j + 3] = (uint1)((input[i] >> 24) & 0xff);	}}// Decodes input (unsigned char) into output (UINT4). Assumes len is// a multiple of 4.void Cout::Encryption::Algorithm::MD5::decode(uint4 *output, uint1 *input, uint4 len) {	unsigned int i, j;	for (i = 0, j = 0; j < len; i++, j += 4)		output[i] = ((uint4)input[j]) | (((uint4)input[j + 1]) << 8) |		(((uint4)input[j + 2]) << 16) | (((uint4)input[j + 3]) << 24);}// Note: Replace "for loop" with standard memcpy if possible.void Cout::Encryption::Algorithm::MD5::memcpy(uint1 *output, uint1 *input, uint4 len) {	unsigned int i;	for (i = 0; i < len; i++)		output[i] = input[i];}// Note: Replace "for loop" with standard memset if possible.void Cout::Encryption::Algorithm::MD5::memset(uint1 *output, uint1 value, uint4 len) {	unsigned int i;	for (i = 0; i < len; i++)		output[i] = value;}// ROTATE_LEFT rotates x left n bits.inline unsigned int Cout::Encryption::Algorithm::MD5::rotate_left(uint4 x, uint4 n) {	return (x << n) | (x >> (32 - n));}// F, G, H and I are basic MD5 functions.inline unsigned int Cout::Encryption::Algorithm::MD5::F(uint4 x, uint4 y, uint4 z) {	return (x & y) | (~x & z);}inline unsigned int Cout::Encryption::Algorithm::MD5::G(uint4 x, uint4 y, uint4 z) {	return (x & z) | (y & ~z);}inline unsigned int Cout::Encryption::Algorithm::MD5::H(uint4 x, uint4 y, uint4 z) {	return x ^ y ^ z;}inline unsigned int Cout::Encryption::Algorithm::MD5::I(uint4 x, uint4 y, uint4 z) {	return y ^ (x | ~z);}// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.// Rotation is separate from addition to prevent recomputation.inline void Cout::Encryption::Algorithm::MD5::FF(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,	uint4  s, uint4 ac) {	a += F(b, c, d) + x + ac;	a = rotate_left(a, s) + b;}inline void Cout::Encryption::Algorithm::MD5::GG(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,	uint4 s, uint4 ac) {	a += G(b, c, d) + x + ac;	a = rotate_left(a, s) + b;}inline void Cout::Encryption::Algorithm::MD5::HH(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,	uint4 s, uint4 ac) {	a += H(b, c, d) + x + ac;	a = rotate_left(a, s) + b;}inline void Cout::Encryption::Algorithm::MD5::II(uint4& a, uint4 b, uint4 c, uint4 d, uint4 x,	uint4 s, uint4 ac) {	a += I(b, c, d) + x + ac;	a = rotate_left(a, s) + b;}
namespace Cout{	namespace Network	{		namespace Protocol		{			namespace Exceptions			{				namespace Auth				{					class bad_credentials : virtual public Cout::Exceptions::base					{					public:						bad_credentials(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Invalid user login or password";						}					};					class bad_digest_response : virtual public Cout::Exceptions::base					{					public:						bad_digest_response(const std::string& whre, const std::string& when) : base(whre, when) { };						const std::string what() const noexcept override						{							return "Server returned a bad digest MD5 response";						}					};				}			}		}	}}
std::string Cout::Network::Protocol::Authentication::Method::Plain(const std::string& login, const std::string& pass){	std::string s = login + "^" + login + "^" + pass;	size_t length = s.size();	UnsignedBinary ustrLogin;	ustrLogin.Assign((UnsignedByte*)s.data(), s.size());	for (unsigned int i = 0; i < length; i++)	{		if (ustrLogin[i] == 94) ustrLogin[i] = 0;	}	Encryption::Algorithm::Base64 base64;	return Core::Utils::to_string(base64.Encode(ustrLogin).data());}std::string Cout::Network::Protocol::Authentication::Method::Login(const std::string& credentials){	Encryption::Algorithm::Base64 base64;	UnsignedBinary res;	res.Assign((UnsignedByte*)credentials.data(), credentials.size());	res = base64.Encode(res);	res.push_back(0);	return Core::Utils::to_string(res.data());}std::string Cout::Network::Protocol::Authentication::Method::CramMD5(const std::string& encoded_challenge, const std::string& login, const std::string& pass){	Encryption::Algorithm::Base64 base64;	UnsignedBinary temp;	temp.Assign((UnsignedByte*)encoded_challenge.data(), encoded_challenge.size());	UnsignedBinary decoded_challenge = base64.Decode(temp);	decoded_challenge.push_back(0);	/////////////////////////////////////////////////////////////////////	//test data from RFC 2195	//decoded_challenge = "<1896.697170952@postoffice.reston.mci.net>";	//m_sLogin = "tim";	//m_sPassword = "tanstaaftanstaaf";	//MD5 should produce b913a602c7eda7a495b4e6e7334d3890	//should encode as dGltIGI5MTNhNjAyYzdlZGE3YTQ5NWI0ZTZlNzMzNGQzODkw	/////////////////////////////////////////////////////////////////////	unsigned char *ustrChallenge = decoded_challenge.data();	unsigned char *ustrPassword = Cout::Core::Utils::StringToUnsignedChar(pass);	// if ustrPassword is longer than 64 bytes reset it to ustrPassword=MD5(ustrPassword)	size_t passwordLength = pass.size();	if (passwordLength > 64) {		Encryption::Algorithm::MD5 md5password;		md5password.update(ustrPassword, passwordLength);		md5password.finalize();		ustrPassword = md5password.raw_digest();		passwordLength = 16;	}	// Storing ustrPassword in pads	unsigned char ipad[65], opad[65];	memset(ipad, 0, 64);	memset(opad, 0, 64);	memcpy(ipad, ustrPassword, passwordLength);	memcpy(opad, ustrPassword, passwordLength);	// XOR ustrPassword with ipad and opad values	for (int i = 0; i < 64; i++) {		ipad[i] ^= 0x36;		opad[i] ^= 0x5c;	}	// perform inner MD5	Encryption::Algorithm::MD5 md5pass1;	md5pass1.update(ipad, 64);	md5pass1.update(ustrChallenge, decoded_challenge.size());	md5pass1.finalize();	unsigned char *ustrResult = md5pass1.raw_digest();	// perform outer MD5	Encryption::Algorithm::MD5 md5pass2;	md5pass2.update(opad, 64);	md5pass2.update(ustrResult, 16);	md5pass2.finalize();		const std::string decoded_str = login + " " + md5pass2.hex_digest();	decoded_challenge.Assign((UnsignedByte*)decoded_str.c_str(), decoded_str.size());	return Core::Utils::to_string(base64.Encode(decoded_challenge).data());}std::string Cout::Network::Protocol::Authentication::Method::DigestMD5(	const std::string& encoded_challenge,	const std::string& charset, 	const std::string& addr, 	const std::string& login, 	const std::string& pass){	Encryption::Algorithm::Base64 base64;	UnsignedBinary temp;	temp.Assign((UnsignedByte*)encoded_challenge.data(), encoded_challenge.size());	temp = base64.Decode(temp);	temp.push_back(0);	std::string decoded_challenge = Core::Utils::to_string(temp.data());	/////////////////////////////////////////////////////////////////////	//Test data from RFC 2831	//To test jump into authenticate and read this line and the ones down to next test data section	//decoded_challenge = "realm=\"elwood.innosoft.com\",nonce=\"OA6MG9tEQGm2hh\",qop=\"auth\",algorithm=md5-sess,charset=utf-8";	/////////////////////////////////////////////////////////////////////	//Get the nonce (manditory)	size_t find = decoded_challenge.find("nonce");	if (find < 0)		throw Exceptions::Auth::bad_digest_response(WHERE, "decoded challenge not contains nonce");	std::string nonce = decoded_challenge.substr(find + 7);	find = nonce.find("\"");	if (find < 0)		throw Exceptions::Auth::bad_digest_response(WHERE, "invalid decoded challenge");	nonce = nonce.substr(0, find);	//Get the realm (optional)	std::string realm;	find = decoded_challenge.find("realm");	if (find >= 0) {		realm = decoded_challenge.substr(find + 7);		find = realm.find("\"");		if (find < 0)			throw Exceptions::Auth::bad_digest_response(WHERE, "invalid decoded challenge");		realm = realm.substr(0, find);	}	//Create a cnonce	std::stringstream tempn;	tempn << std::hex << (unsigned int)time(NULL);	std::string cnonce = tempn.str();	//Set nonce count	std::string nc = "00000001";	//Set QOP	std::string qop = "auth";	// set uri	std::string uri = "smtp/" + addr;	/////////////////////////////////////////////////////////////////////	//test data from RFC 2831	//m_sLogin = "chris";	//m_sPassword = "secret";	//snprintf(cnonce, 17, "OA6MHXh6VqTrRk");	//uri = "imap/elwood.innosoft.com";	//Should form the response:	//    charset=utf-8,username="chris",	//    realm="elwood.innosoft.com",nonce="OA6MG9tEQGm2hh",nc=00000001,	//    cnonce="OA6MHXh6VqTrRk",digest-uri="imap/elwood.innosoft.com",	//    response=d388dad90d4bbd760a152321f2143af7,qop=auth	//This encodes to:	//    Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iY2hyaXMiLHJlYWxtPSJlbHdvb2	//    QuaW5ub3NvZnQuY29tIixub25jZT0iT0E2TUc5dEVRR20yaGgiLG5jPTAw	//    MDAwMDAxLGNub25jZT0iT0E2TUhYaDZWcVRyUmsiLGRpZ2VzdC11cmk9Im	//    ltYXAvZWx3b29kLmlubm9zb2Z0LmNvbSIscmVzcG9uc2U9ZDM4OGRhZDkw	//    ZDRiYmQ3NjBhMTUyMzIxZjIxNDNhZjcscW9wPWF1dGg=	/////////////////////////////////////////////////////////////////////	//Calculate digest response	unsigned char *ustrRealm = Cout::Core::Utils::StringToUnsignedChar(realm);	unsigned char *ustrUsername = Cout::Core::Utils::StringToUnsignedChar(login);	unsigned char *ustrPassword = Cout::Core::Utils::StringToUnsignedChar(pass);	unsigned char *ustrNonce = Cout::Core::Utils::StringToUnsignedChar(nonce);	unsigned char *ustrCNonce = Cout::Core::Utils::StringToUnsignedChar(cnonce);	unsigned char *ustrUri = Cout::Core::Utils::StringToUnsignedChar(uri);	unsigned char *ustrNc = Cout::Core::Utils::StringToUnsignedChar(nc);	unsigned char *ustrQop = Cout::Core::Utils::StringToUnsignedChar(qop);	if (!ustrRealm || !ustrUsername || !ustrPassword || !ustrNonce || !ustrCNonce || !ustrUri || !ustrNc || !ustrQop)		throw Exceptions::Auth::bad_credentials(WHERE, "digest-m5 invalid decoded challenge");	Encryption::Algorithm::MD5 md5a1a;	md5a1a.update(ustrUsername, login.size());	md5a1a.update((unsigned char*)":", 1);	md5a1a.update(ustrRealm, realm.size());	md5a1a.update((unsigned char*)":", 1);	md5a1a.update(ustrPassword, pass.size());	md5a1a.finalize();	unsigned char *ua1 = md5a1a.raw_digest();	Encryption::Algorithm::MD5 md5a1b;	md5a1b.update(ua1, 16);	md5a1b.update((unsigned char*)":", 1);	md5a1b.update(ustrNonce, nonce.size());	md5a1b.update((unsigned char*)":", 1);	md5a1b.update(ustrCNonce, strlen(cnonce.c_str()));	//authzid could be added here	md5a1b.finalize();	char *a1 = md5a1b.hex_digest();	Encryption::Algorithm::MD5 md5a2;	md5a2.update((unsigned char*) "AUTHENTICATE:", 13);	md5a2.update(ustrUri, uri.size());	//authint and authconf add an additional line here		md5a2.finalize();	char *a2 = md5a2.hex_digest();	delete[] ua1;	ua1 = Cout::Core::Utils::StringToUnsignedChar(a1);	unsigned char *ua2 = Cout::Core::Utils::StringToUnsignedChar(a2);	//compute KD	Encryption::Algorithm::MD5 md5;	md5.update(ua1, 32);	md5.update((unsigned char*)":", 1);	md5.update(ustrNonce, nonce.size());	md5.update((unsigned char*)":", 1);	md5.update(ustrNc, strlen(nc.c_str()));	md5.update((unsigned char*)":", 1);	md5.update(ustrCNonce, strlen(cnonce.c_str()));	md5.update((unsigned char*)":", 1);	md5.update(ustrQop, qop.size());	md5.update((unsigned char*)":", 1);	md5.update(ua2, 32);	md5.finalize();	decoded_challenge = md5.hex_digest();		std::stringstream resstream(charset);	resstream << "username=\"" + login + "\"";	if (!realm.empty()) {		resstream << ",realm=\"" + realm + "\"";	}	resstream << ",nonce=\"" + nonce + "\"";	resstream << ",nc=\"" + nc + "\"";	resstream << ",cnonce=\"" + cnonce + "\"";	resstream << ",digest-uri=\"" + uri + "\"";	resstream << ",response=\"" + decoded_challenge + "\"";	resstream << ",qop=\"" + qop + "\"";	std::string resstr = resstream.str();	UnsignedBinary ustrDigest;	ustrDigest.Assign((UnsignedByte*)resstr.c_str(), resstr.size());	return Core::Utils::to_string(base64.Encode(ustrDigest).data());}
Cout::Network::Protocol::SMTP::ESMTPSA::ESMTPSA() : pendingTransaction(false), Secured(), m_sLocalHostName(GetLocalName()){	DEBUG_LOG(3, "Initializing ESMTPSA protocol");}Cout::Network::Protocol::SMTP::ESMTPSA::~ESMTPSA(){	if (isConnected) 		Disconnect();}void Cout::Network::Protocol::SMTP::ESMTPSA::Send(){	Secured::Send();}void Cout::Network::Protocol::SMTP::ESMTPSA::Receive(){	Secured::Receive();}void Cout::Network::Protocol::SMTP::ESMTPSA::Init(){	DEBUG_LOG(2, "Initializing SMTP protocol");	Receive();	if (isRetCodeValid(500))		throw Cout::Network::Protocol::Exceptions::smtp::command_not_recognized(WHERE, "The server uses an outdated specification and does not support extensions");	if (!isRetCodeValid(220))		throw Cout::Network::Protocol::Exceptions::wsa::server_not_responding(WHERE, "SMTP init");}void Cout::Network::Protocol::SMTP::ESMTPSA::Disconnect(){	DEBUG_LOG(2, "SMTP Disconnecting");	if (isConnected)	{		Command(QUIT);	}	Secured::Disconnect();}void Cout::Network::Protocol::SMTP::ESMTPSA::Quit(){	DEBUG_LOG(3, "Sending QUIT command");	if (pendingTransaction)	{		// close pending transaction first		SendBuf = "\r\n.\r\n";		Send();		Receive();	}	SendBuf = "QUIT\r\n";	Send();	Receive();	if (!isRetCodeValid(221))		throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending QUIT command");}void Cout::Network::Protocol::SMTP::ESMTPSA::MailFrom(){	DEBUG_LOG(3, "Sending MAIL FROM command");	if (!mail->GetMailFrom().size())		throw Cout::Network::Protocol::Exceptions::smtp::undef_mail_from(WHERE, "sending MAIL FROM command");	SendBuf = "MAIL FROM:<" + mail->GetMailFrom() + ">\r\n";	Send();	Receive();	if (!isRetCodeValid(250))		throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending MAIL FROM command");}void Cout::Network::Protocol::SMTP::ESMTPSA::RCPTto(){	DEBUG_LOG(3, "Sending RCPT TO command");	if (!mail->GetRecipientCount())		throw Cout::Network::Protocol::Exceptions::smtp::undef_recipients(WHERE, "sending RCPT TO command");	const auto& recipients = mail->GetRecipient();	for (const auto& [mail, name] : recipients)	{		// RCPT <SP> TO:<forward-path> <CRLF>		SendBuf = "RCPT TO:<" + mail + ">\r\n";		Send();		Receive();		if (!isRetCodeValid(250))			throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending recipients by RCPT TO command");	}	const auto& ccrecipients = mail->GetCCRecipient();	for (const auto& [mail, name] : ccrecipients)	{		// RCPT <SP> TO:<forward-path> <CRLF>		SendBuf = "RCPT TO:<" + mail + ">\r\n";		Send();		Receive();		if (!isRetCodeValid(250))			throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending ccrecipients by RCPT TO command");	}	const auto& bccrecipients = mail->GetBCCRecipient();	for (const auto& [mail, name] : bccrecipients)	{		// RCPT <SP> TO:<forward-path> <CRLF>		SendBuf = "RCPT TO:<" + mail + ">\r\n";		Send();		Receive();		if (!isRetCodeValid(250))			throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending bccrecipients by RCPT TO command");	}}void Cout::Network::Protocol::SMTP::ESMTPSA::Data(){	DEBUG_LOG(3, "Sending DATA command");	SendBuf = "DATA\r\n";	Send();	Receive();	if (!isRetCodeValid(354))		throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "sending DATA command");}void Cout::Network::Protocol::SMTP::ESMTPSA::Datablock(){	DEBUG_LOG(2, "Sending mail header");	SendBuf = mail->createHeader();	Send();	DEBUG_LOG(2, "Sending mail body");	if (!mail->GetBodySize())	{		SendBuf = " \r\n";		Send();	}	const auto& body = mail->GetBody();	for (const auto& line : body)	{		SendBuf = line + "\r\n";		Send();	}	const auto& attachments = mail->GetAttachments();	for (const auto& path : attachments)	{		DEBUG_LOG(2, "Sending the attachment file");		unsigned long long FileSize, TotalSize;		unsigned long long MsgPart;		std::string FileName, EncodedFileName;		std::string::size_type pos;		TotalSize = 0;		DEBUG_LOG(3, "Checking file for existing");		Core::Filesystem::Explorer explorer;		if (!explorer.exist(path))			throw Cout::Exceptions::Core::file_not_exist(WHERE, "SMTP attachment file not found");		DEBUG_LOG(3, "Checking file size");		FileSize = explorer.size(path);		TotalSize += FileSize;		if (TotalSize / 1024 > MSG_SIZE_IN_MB * 1024)			throw Cout::Network::Protocol::Exceptions::smtp::msg_too_big(WHERE, "SMTP attachment files are too large");		DEBUG_LOG(3, "Sending file header");		pos = path.find_last_of("\\");		if (pos == std::string::npos) FileName = path;		else FileName = path.substr(pos + 1);		Encryption::Algorithm::Base64 base64;		UnsignedBinary fnamebin;		fnamebin.Assign((UnsignedByte*)FileName.c_str(), FileName.size());		//RFC 2047 - Use UTF-8 charset,base64 encode.		EncodedFileName = "=?UTF-8?B?";		EncodedFileName += Core::Utils::to_string(base64.Encode(fnamebin).data());		EncodedFileName += "?=";		SendBuf = "--" + MAIL::BOUNDARY_TEXT + "\r\n";		SendBuf += "Content-Type: application/x-msdownload; name=\"";		SendBuf += EncodedFileName;		SendBuf += "\"\r\n";		SendBuf += "Content-Transfer-Encoding: base64\r\n";		SendBuf += "Content-Disposition: attachment; filename=\"";		SendBuf += EncodedFileName;		SendBuf += "\"\r\n";		SendBuf += "\r\n";		Send();		DEBUG_LOG(3, "Sending file body");		MsgPart = 0;		explorer.read(path, 54, [&base64, &MsgPart, this] (const Binary& block) mutable {			UnsignedBinary bin_block;			bin_block.Assign((UnsignedByte*)block.data(), block.size());			MsgPart ? SendBuf += Core::Utils::to_string(base64.Encode(bin_block).data())				: SendBuf = Core::Utils::to_string(base64.Encode(bin_block).data());			SendBuf += "\r\n";			MsgPart += block.size() + 2ull;			if (MsgPart >= BUFFER_SIZE / 2)			{				// sending part of the message				MsgPart = 0;				Send();			}		});		if (MsgPart)		{			Send();		}	}	if (mail->GetAttachmentsSize())	{		SendBuf = "\r\n--" + MAIL::BOUNDARY_TEXT + "--\r\n";		Send();	}}void Cout::Network::Protocol::SMTP::ESMTPSA::DataEnd(){	DEBUG_LOG(3, "Sending the CRLF");	// <CRLF> . <CRLF>	SendBuf = "\r\n.\r\n";	Send();	Receive();	if (!isRetCodeValid(250))		throw Cout::Network::Protocol::Exceptions::smtp::msg_body_error(WHERE, "wrong letter format");}const std::string& Cout::Network::Protocol::SMTP::ESMTPSA::GetLogin() const noexcept{	return credentials.login;}const std::string& Cout::Network::Protocol::SMTP::ESMTPSA::GetPassword() const noexcept{	return credentials.password;}void Cout::Network::Protocol::SMTP::ESMTPSA::SetLogin(const std::string& login){	credentials.login = login;}void Cout::Network::Protocol::SMTP::ESMTPSA::SetPassword(const std::string& pass){	credentials.password = pass;}bool Cout::Network::Protocol::SMTP::ESMTPSA::isRetCodeValid(int validCode) const{	if (!RecvBuf.size())		return false;	int receiveCode;	std::stringstream iss;	iss << RecvBuf[0] << RecvBuf[1] << RecvBuf[2];	iss >> receiveCode;	bool retCodeValid = (validCode == receiveCode);	return retCodeValid;}void Cout::Network::Protocol::SMTP::ESMTPSA::Command(COMMAND command){	switch (command)	{	case INIT:		Init();		break;	case EHLO:		Ehlo();		break;	case STARTTLS:		Starttls();		break;	case MAILFROM:		MailFrom();		break;	case RCPTTO:		RCPTto();		break;	case DATA:		Data();		break;	case DATABLOCK:		Datablock();		break;	case DATAEND:		DataEnd();		break;	case AUTHPLAIN:		AuthPlain();		break;	case AUTHLOGIN:		AuthLogin();		break;	case AUTHCRAMMD5:		CramMD5();		break;	case AUTHDIGESTMD5:		DigestMD5();		break;	case QUIT:		Quit();		break;	default:		throw Cout::Network::Protocol::Exceptions::smtp::undef_command(WHERE, "specifying a command");		break;	}}// A simple string matchbool Cout::Network::Protocol::SMTP::ESMTPSA::IsCommandSupported(const std::string& response, const std::string& command) const{	return response.find(command) != std::string::npos;}int Cout::Network::Protocol::SMTP::ESMTPSA::SmtpXYZdigits() const{	if (RecvBuf.empty())		return 0;	return (RecvBuf[0] - '0') * 100 + (RecvBuf[1] - '0') * 10 + RecvBuf[2] - '0';}void Cout::Network::Protocol::SMTP::ESMTPSA::Handshake(){	DEBUG_LOG(1, "SMTP Handshake");	Command(INIT);	Command(EHLO);}void Cout::Network::Protocol::SMTP::ESMTPSA::Starttls(){	DEBUG_LOG(3, "Sending STARTTLS command");	SendBuf = "STARTTLS\r\n";	Send();	Receive();	if (!isRetCodeValid(220))		throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "attempt to set up tls over SMTP");}void Cout::Network::Protocol::SMTP::ESMTPSA::Ehlo(){	DEBUG_LOG(3, "Sending EHLO command");	SendBuf = "EHLO ";	SendBuf += m_sLocalHostName.empty() ? "localhost" : m_sLocalHostName;	SendBuf += "\r\n";	Send();	Receive();	if (!isRetCodeValid(250))		throw Cout::Network::Protocol::Exceptions::smtp::command_failed(WHERE, "server return error after EHLO command");}void Cout::Network::Protocol::SMTP::ESMTPSA::SetUpSSL(){	DEBUG_LOG(2, "Setting up SSL over ESMTP");	Secured::SetUpSSL();	DEBUG_LOG(2, "Successfuly set up SSL over ESMTP connection");}void Cout::Network::Protocol::SMTP::ESMTPSA::SetUpTLS(){	DEBUG_LOG(2, "Setting up TLS over ESMTP");	if (IsCommandSupported(RecvBuf.data(), "STARTTLS") == false)	{		throw Cout::Network::Protocol::Exceptions::smtp::tls_not_supported(WHERE, "attempt to set up TLS over ESMTP");	}	Command(STARTTLS);	Secured::SetUpSSL();	Command(EHLO);	DEBUG_LOG(2, "Successfuly set up TLS over ESMTP connection");}void Cout::Network::Protocol::SMTP::ESMTPSA::Connect(const std::string& host, unsigned short port){	DEBUG_LOG(1, "ESMTPSA Connecting");	Secured::Connect(host, port);	if (sec == Protocol::Secured::Type::SSL)	{		SetUpSSL();	}	Handshake();	if (sec == Protocol::Secured::Type::TLS)	{		SetUpTLS();	}	Auth();}void Cout::Network::Protocol::SMTP::ESMTPSA::Send(MAIL* m){	mail = m;	Command(MAILFROM);	Command(RCPTTO);	Command(DATA);	DEBUG_LOG(1, "Start SMTP transaction");	pendingTransaction = true;	Command(DATABLOCK);	Command(DATAEND);	pendingTransaction = false;	DEBUG_LOG(1, "Success SMTP transaction");	mail = nullptr;}void Cout::Network::Protocol::SMTP::ESMTPSA::Auth(){	DEBUG_LOG(3, "Choosing authentication");	if (IsCommandSupported(RecvBuf.data(), "AUTH"))	{		if (!credentials.login.size())			throw Cout::Network::Protocol::Exceptions::smtp::undef_login(WHERE, "SMTP authentication selection");		if (!credentials.password.size())			throw Cout::Network::Protocol::Exceptions::smtp::undef_password(WHERE, "SMTP authentication selection");		if (IsCommandSupported(RecvBuf.data(), "LOGIN") == true)		{			Command(AUTHLOGIN);		}		else if (IsCommandSupported(RecvBuf.data(), "PLAIN") == true)		{			Command(AUTHPLAIN);		}		else if (IsCommandSupported(RecvBuf.data(), "CRAM-MD5") == true)		{			Command(AUTHCRAMMD5);		}		else if (IsCommandSupported(RecvBuf.data(), "DIGEST-MD5") == true)		{			Command(AUTHDIGESTMD5);		}		else		{			throw Cout::Network::Protocol::Exceptions::smtp::auth_not_supported(WHERE, "SMTP authentication selection");		}	}	else	{		throw Cout::Network::Protocol::Exceptions::smtp::auth_not_supported(WHERE, "SMTP authentication selection");	}}void Cout::Network::Protocol::SMTP::ESMTPSA::AuthPlain(){	DEBUG_LOG(2, "Authentication AUTH PLAIN");	SendBuf = "AUTH PLAIN " + Authentication::Method::Plain(credentials.login, credentials.password) + "\r\n";	Send();	Receive();	if (!isRetCodeValid(235))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP Plain authentication");}void Cout::Network::Protocol::SMTP::ESMTPSA::AuthLogin(){	DEBUG_LOG(2, "Authentication AUTH LOGIN");	SendBuf = "AUTH LOGIN\r\n";	Send();	Receive();	if (!isRetCodeValid(334))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP LOGIN authentication");	DEBUG_LOG(3, "Sending login");	std::string encoded_login = Authentication::Method::Login(credentials.login);	SendBuf = encoded_login + "\r\n";	Send();	Receive();	if (!isRetCodeValid(334))		throw Cout::Network::Protocol::Exceptions::smtp::undef_response(WHERE, "SMTP LOGIN authentication");	DEBUG_LOG(3, "Sending password");	std::string encoded_password = Authentication::Method::Login(credentials.password);	SendBuf = encoded_password + "\r\n";	Send();	Receive();	if (!isRetCodeValid(235))	{		throw Cout::Network::Protocol::Exceptions::smtp::bad_credentials(WHERE, "SMTP LOGIN authentication");	}}void Cout::Network::Protocol::SMTP::ESMTPSA::CramMD5(){	DEBUG_LOG(2, "Authentication AUTH CRAM-MD5");	SendBuf = "AUTH CRAM-MD5\r\n";	Send();	Receive();	if (!isRetCodeValid(334))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP CRAM-MD5 authentication");	DEBUG_LOG(3, "Token generation");	std::string encoded_challenge = Authentication::Method::CramMD5(std::string(RecvBuf.data()).substr(4), credentials.login, credentials.password);	SendBuf = encoded_challenge + "\r\n";	DEBUG_LOG(1, "Token sending " + encoded_challenge);	Send();	Receive();	if (!isRetCodeValid(334))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP CRAM-MD5 authentication");}void Cout::Network::Protocol::SMTP::ESMTPSA::DigestMD5(){	DEBUG_LOG(2, "Authentication AUTH DIGEST-MD5");	SendBuf = "AUTH DIGEST-MD5\r\n";	Send();	Receive();	if (!isRetCodeValid(335))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP DIGEST-MD5 authentication");	DEBUG_LOG(3, "Token generation");	const std::string charset = std::string(RecvBuf.data()).find("charset") != std::string::npos ?		"charset=utf-8," : "";	const std::string addr = Core::Utils::to_string(host) + ":" + Core::Utils::to_string(port);	std::string encoded_challenge = Authentication::Method::DigestMD5(std::string(RecvBuf.data()).substr(4), charset, addr, credentials.login, credentials.password);	SendBuf = encoded_challenge + "\r\n";	DEBUG_LOG(3, "Token sending " + encoded_challenge);	Send();	Receive();	if (!isRetCodeValid(335))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP DIGEST-MD5 authentication");	// only completion carraige needed for end digest md5 auth	SendBuf = "\r\n";	Send();	Receive();	if (!isRetCodeValid(335))		throw Cout::Network::Protocol::Exceptions::smtp::auth_failed(WHERE, "SMTP DIGEST-MD5 authentication");}
#include <string>namespace Cout{	namespace Network	{		class SMTPClient : private Core::Pattern::Facade<Protocol::SMTP::ESMTPSA>		{		public:			SMTPClient();			void SetServer(Protocol::SMTP::Server::ID id);			void SetLogin(const std::string& login);			void SetPassword(const std::string& pass);			const std::string& GetLogin() const noexcept;			const std::string& GetPassword() const noexcept;			void Send(Protocol::SMTP::MAIL* mail);			static const std::map<const Protocol::SMTP::Server::ID, const Protocol::SMTP::Server> supported;		};	}}
Cout::Network::SMTPClient::SMTPClient(){	DEBUG_LOG(3, "Initializing SMTP Client");}void Cout::Network::SMTPClient::Send(Cout::Network::Protocol::SMTP::MAIL* mail){	if (mail->GetSenderMail().empty())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "sender not specified");	if (!mail->GetRecipientCount())		throw Cout::Exceptions::Core::invalid_argument(WHERE, "receiver not specified");	mail->SetXPriority(Cout::Network::Protocol::SMTP::MAIL::PRIORITY::NORMAL);	mail->SetXMailer("My email client");	_component->Connect(_component->host, _component->port);	_component->Send(mail);	_component->Disconnect();}void Cout::Network::SMTPClient::SetLogin(const std::string& login){	_component->SetLogin(login);}void Cout::Network::SMTPClient::SetPassword(const std::string& pass){	_component->SetPassword(pass);}const std::string& Cout::Network::SMTPClient::GetLogin() const noexcept{	return _component->GetLogin();}const std::string& Cout::Network::SMTPClient::GetPassword() const noexcept{	return _component->GetPassword();}void Cout::Network::SMTPClient::SetServer(Cout::Network::Protocol::SMTP::Server::ID id){	_component->host = supported.at(id).host;	_component->port = supported.at(id).port;	_component->sec = supported.at(id).sec;}const std::map<const Cout::Network::Protocol::SMTP::Server::ID, const Cout::Network::Protocol::SMTP::Server> Cout::Network::SMTPClient::supported = {	{		Cout::Network::Protocol::SMTP::Server::GMAIL_TLS,		{			Cout::Network::Protocol::Secured::Type::TLS,	"smtp.gmail.com",			587		}	},	{		Cout::Network::Protocol::SMTP::Server::GMAIL_SSL,		{			Cout::Network::Protocol::Secured::Type::SSL,	"smtp.gmail.com",			465		}	},	{		Cout::Network::Protocol::SMTP::Server::HOTMAIL_TSL,		{			Cout::Network::Protocol::Secured::Type::TLS,	"smtp.live.com",			25		}	},	{		Cout::Network::Protocol::SMTP::Server::AOL_TLS,		{			Cout::Network::Protocol::Secured::Type::TLS,	"smtp.aol.com",				587		}	},	{		Cout::Network::Protocol::SMTP::Server::YAHOO_SSL,		{			Cout::Network::Protocol::Secured::Type::SSL,	"plus.smtp.mail.yahoo.com",	465		}	}};
